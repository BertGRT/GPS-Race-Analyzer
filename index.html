<!DOCTYPE html>
<html lang="fr">
<head>

   
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
     <!-- PWA Support -->
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#667eea">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="GPS LapTimer">
<link rel="apple-touch-icon" href="./icon-192.png">

<script>
// Enregistrer le service worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('✅ Service Worker enregistré', reg.scope))
      .catch(err => console.error('❌ Erreur SW:', err));
  });
}
</script>
    <title>GPS Race Analyzer Pro</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

         /* ========== VARIABLES POUR MODE SOMBRE ========== */
    :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-card: #ffffff;
        --text-primary: #333333;
        --text-secondary: #666666;
        --border-color: #e0e0e0;
        --shadow: rgba(0, 0, 0, 0.1);
        --gradient-1: #667eea;
        --gradient-2: #764ba2;
        --accent: #1976d2;
    }
    
    [data-theme="dark"] {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --bg-card: #252525;
        --text-primary: #e0e0e0;
        --text-secondary: #b0b0b0;
        --border-color: #404040;
        --shadow: rgba(0, 0, 0, 0.5);
        --gradient-1: #667eea;
        --gradient-2: #764ba2;
        --accent: #64b5f6;
    }
    /* ================================================= */
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        min-height: 100vh;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: background 0.3s ease, color 0.3s ease;
    }
        
                
        .header {
            text-align: center;
            color: white;
            padding: 30px;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        
        .container {
    max-width: 1200px;
    margin: 0 auto;
    background: var(--bg-card);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 10px 40px var(--shadow);
    transition: background 0.3s ease, box-shadow 0.3s ease;    
}

/* Bouton mode sombre */
/* Toggle mode sombre (curseur minimaliste) */
.theme-toggle-container {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    margin-bottom: 20px;
    gap: 10px;
}

.theme-toggle-label {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.theme-toggle {
    position: relative;
    width: 50px;
    height: 24px;
    background: #ccc;
    border-radius: 24px;
    cursor: pointer;
    transition: background 0.3s ease;
    border: none;
    padding: 0;
}

.theme-toggle[data-theme="dark"] {
    background: var(--accent);
}

.theme-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.theme-toggle[data-theme="dark"]::after {
    transform: translateX(26px);
}

.theme-toggle.hidden {
    display: none !important;
}
        
        .upload-area {
    border: 3px dashed var(--accent);
    border-radius: 15px;
    padding: 60px 40px;
    text-align: center;
    background: var(--bg-card);
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 30px;
    position: relative;
}

       

#home-page {
    display: block;
    max-width: 800px; /* AJOUTÉ : centrer le contenu */
    margin: 0 auto; /* AJOUTÉ : centrer */
}

.connection-card {
    background: var(--bg-secondary);
    border-radius: 20px;
    padding: 30px;
    margin: 20px 0;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 3px solid transparent;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 20px;
}

.connection-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px var(--shadow);
    border-color: var(--accent);
}

.connection-icon {
    font-size: 3rem; /* RÉDUIT de 4rem à 3rem */
    min-width: 60px; /* AJOUTÉ : largeur fixe pour l'icône */
    text-align: center;
}

.connection-card h3 {
    color: var(--accent);
    margin-bottom: 5px;
    font-size: 1.3rem;
}

.connection-card p {
    color: var(--text-secondary);
    margin: 0;
    font-size: 0.95rem;
}

.back-button {
    background: #2196f3;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    margin-bottom: 20px;
    transition: all 0.2s ease;
}

.back-button:hover {
    background: #1976d2;
    transform: translateX(-3px);
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 8px;
}
/* ===== STYLES POUR LA LISTE DES FICHIERS ===== */

.file-item {
    background: var(--bg-secondary);
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
    border-left: 4px solid var(--accent);
    transition: all 0.2s ease;
    display: flex;
    gap: 15px;
    align-items: flex-start;
}

.file-item:hover {
    background: var(--bg-card);
    box-shadow: 0 4px 12px var(--shadow);
}

.file-item-checkbox {
    margin-top: 5px;
}

.file-item-checkbox input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.file-item-content {
    flex: 1;
}

.file-item.selected {
    background: #e8f5e9;
    border-left-color: #4caf50;
}

[data-theme="dark"] .file-item.selected { 
    background: #2d2d2d !important;
    border: 2px solid #4caf50 !important;
    border-left: 4px solid #4caf50 !important;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); /* Légère lueur verte */
}

.file-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.file-item-title {
    font-weight: bold;
    color: var(--accent);
    font-size: 1.1rem;
}
.file-item-date {
    color: var(--text-secondary);
    font-size: 0.9rem;
}
.file-item-stats {
    display: flex;
    gap: 15px;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.file-item-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.file-action-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-load {
    background: #2196f3;
    color: white;
}

.btn-delete {
    background: #f44336;
    color: white;
}

.file-action-btn:hover {
    transform: scale(1.05);
}
        
        .upload-area:hover {
    border-color: var(--accent);
    background: var(--bg-secondary);
    transform: translateY(-5px);
}
        
        .upload-area.drag-over {
            background: #f0f0f0;
            color: white;
            transform: scale(1.02);
        }
        
        .upload-icon { font-size: 4rem; margin-bottom: 20px; }
        
        #session-content { display: none; }
        
        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .session-info h2 { font-size: 1.8rem; color: #1976d2; margin-bottom: 5px; }
        .session-date { color: #666; }
        
        .session-badge {
    display: none !important;
}
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
    background: linear-gradient(45deg, #1976d2, #42a5f5); /* Même dégradé que le tableau */
    color: white;
    padding: 25px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 8px 25px rgba(25, 118, 210, 0.3); /* Ombre bleue au lieu de violette */
    transition: transform 0.3s ease;
}

.stat-value {
    font-size: 2rem;
    font-weight: bold;
    margin-bottom: 8px;
}

.stat-label {
    font-size: 0.85rem;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 1px;
}
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid #e0e0e0;
            flex-wrap: wrap;
        }
        
        .tab {
    padding: 12px 25px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-weight: 500;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.tab:hover { color: var(--accent); }

.tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
    font-weight: 600;
}
        
        .tab-content {
            display: none;
            animation: fadeIn 0.4s ease;
        }
        
        .tab-content.active { display: block; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        table thead {
            background: linear-gradient(45deg, #1976d2, #42a5f5);
            color: white;
        }
        
        table th, table td {
    padding: 12px 10px;
    text-align: center;
    border-bottom: 1px solid var(--border-color);
}

table tbody tr {
    background: var(--bg-card);
    transition: background 0.2s ease;
}

table tbody tr:hover { 
    background: var(--bg-secondary); 
}
        table tbody tr.best-lap { 
    background: #e8f5e9 !important; 
    font-weight: bold; 
}

[data-theme="dark"] table tbody tr.best-lap { 
    background: #2d2d2d !important;
    border-left: 4px solid #4caf50 !important;
    color: #4caf50 !important;
    font-weight: bold;
}
        
        .delta-positive { color: #d32f2f; font-weight: bold; }
        .delta-zero { color: #2e7d32; font-weight: bold; }
        
        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .map-controls button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s ease;
        }
        
        .map-controls button:hover { transform: translateY(-2px); }
        
        .map-container {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 20px 0;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
            min-height: 500px;
            border-radius: 10px;
        }
        
        .track-stats {
            display: none !important;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .track-stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #1976d2;
        }
        
        .track-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1976d2;
        }
        
        .track-stat-label {
            color: #666;
            font-size: 0.9rem;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .analysis-card {
    background: var(--bg-secondary);
    padding: 20px;
    border-radius: 10px;
    border-left: 4px solid var(--gradient-1);
    transition: background 0.3s ease;
}

.analysis-card h4 {
    color: var(--accent);
    margin-bottom: 15px;
}
        
        .progress-bars { margin: 20px 0; }
        
        .progress-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
        }
        
        .progress-label {
            width: 50px;
            font-weight: bold;
            color: #1976d2;
        }
        
        .progress-bar-container {
            flex: 1;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            margin: 0 10px;            
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.85rem;
            font-weight: bold;
            transition: width 0.5s ease;
        }
        
        .export-section {
    margin: 30px 0;
    padding: 20px;
    background: var(--bg-secondary);
    border-radius: 10px;
}

.export-section h3 {
    color: var(--accent) !important;
}

.export-section p {
    color: var(--text-secondary) !important;
}
        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .export-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            color: white;
            transition: transform 0.2s ease;
        }
        
        .export-btn:hover { transform: translateY(-2px); }
        
        .replay-controls {
    background: var(--bg-card);
    padding: 20px;
    border-radius: 10px;
    margin: 20px 0;
    box-shadow: 0 2px 10px var(--shadow);
    transition: background 0.3s ease;
}
        
        .replay-slider {
            width: 100%;
            margin: 15px 0;
        }
        
        .replay-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .replay-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            transition: transform 0.2s ease;
        }
        
        .replay-btn:hover { transform: scale(1.05); }
        
        .replay-info {
            text-align: center;
            margin: 10px 0;
            font-size: 1.1rem;
            font-weight: bold;
            color: #1976d2;
        }
        
        .comparison-controls {
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
        }
        
        .circuit-info {
            background: linear-gradient(135deg, #4caf50, #8bc34a);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .circuit-icon { font-size: 2rem; }
        .circuit-details h4 { margin-bottom: 5px; }
        
        .turns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .turn-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #ff6f00;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .turn-card h4 {
            color: #ff6f00;
            margin-bottom: 15px;
        }
        
        .turn-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .chart-container {
    background: var(--bg-card);
    padding: 20px;
    border-radius: 10px;
    margin: 20px 0;
    box-shadow: 0 2px 10px var(--shadow);
    transition: background 0.3s ease;
}
        
        .chart-container canvas {
            max-height: 400px;
            min-height: 250px;
     }
        
        

/* ==========================================
   CURSEUR GPS - FORCER ABSOLUMENT TOUT
   ========================================== */

/* NIVEAU 1: Leaflet marker container */
.leaflet-marker-icon.replay-marker,
.leaflet-marker-icon.replay-marker *,
div.replay-marker,
div.replay-marker * {
    background: transparent !important;
    background-color: transparent !important;
    background-image: none !important;
    border: none !important;
    box-shadow: none !important;
    overflow: visible !important;
}

/* NIVEAU 2: Le conteneur replay-marker */
.replay-marker,
div[class*="replay-marker"] {
    position: relative !important;
    width: 18px !important;
    height: 18px !important;
    overflow: visible !important;
}

/* NIVEAU 3: Le point rouge - PRIORITÉ ABSOLUE */
.replay-marker-dot,
.replay-marker .replay-marker-dot,
div.replay-marker-dot,
.leaflet-marker-icon .replay-marker-dot {
    width: 18px !important;
    height: 18px !important;
    min-width: 18px !important;
    min-height: 18px !important;
    max-width: 18px !important;
    max-height: 18px !important;
    background: #ff0000 !important;
    background-color: #ff0000 !important;
    border: 3px solid white !important;
    border-radius: 50% !important;
    box-shadow: 0 3px 10px rgba(0,0,0,0.8) !important;
    position: relative !important;
    z-index: 1000 !important;
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
}

/* NIVEAU 4: L'étiquette de vitesse */
.replay-speed-tag,
.replay-marker .replay-speed-tag,
div.replay-speed-tag,
#replay-speed-tag {
    position: absolute !important;
    bottom: 100% !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    background: #ff0000 !important;
    background-color: #ff0000 !important;
    color: white !important;
    padding: 5px 12px !important;
    border-radius: 15px !important;
    font-weight: bold !important;
    font-size: 14px !important;
    white-space: nowrap !important;
    box-shadow: 0 3px 10px rgba(0,0,0,0.8) !important;
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    margin-bottom: 8px !important;
    border: 2px solid white !important;
    z-index: 1001 !important;
    min-width: 65px !important;
    text-align: center !important;
    transition: opacity 0.2s ease, visibility 0.2s ease !important;
}

.replay-speed-tag.visible,
#replay-speed-tag.visible {
    opacity: 1 !important;
    visibility: visible !important;
}

/* Étiquettes de vitesse sur la carte */
.speed-marker { 
    background: transparent !important;
    border: none !important;
    overflow: visible !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

/* NE PAS toucher au background des enfants (étiquettes) */
.speed-marker > div {
    display: inline-block !important;
    min-width: max-content !important;
    /* Le background/border est géré par le JavaScript, ne pas écraser */
}

/* MOBILE */
@media (max-width: 768px) {
    .replay-marker,
    div[class*="replay-marker"] {
        width: 16px !important;
        height: 16px !important;
    }
    
    .replay-marker-dot,
    .replay-marker .replay-marker-dot,
    div.replay-marker-dot,
    .leaflet-marker-icon .replay-marker-dot {
        width: 16px !important;
        height: 16px !important;
        min-width: 16px !important;
        min-height: 16px !important;
        max-width: 16px !important;
        max-height: 16px !important;
        border: 3px solid white !important;
    }
    
    .replay-speed-tag,
    #replay-speed-tag {
        font-size: 12px !important;
        padding: 4px 10px !important;
    }
    
    .speed-marker > div {
        font-size: 11px !important;
        padding: 3px 8px !important;
    }
}

@media (max-width: 375px) {
    .replay-marker,
    div[class*="replay-marker"] {
        width: 14px !important;
        height: 14px !important;
    }
    
    .replay-marker-dot,
    .replay-marker .replay-marker-dot,
    div.replay-marker-dot,
    .leaflet-marker-icon .replay-marker-dot {
        width: 14px !important;
        height: 14px !important;
        min-width: 14px !important;
        min-height: 14px !important;
        max-width: 14px !important;
        max-height: 14px !important;
        border: 2px solid white !important;
    }
    
    .replay-speed-tag,
    #replay-speed-tag {
        font-size: 11px !important;
        padding: 3px 8px !important;
    }
}

/* Forcer overflow visible PARTOUT */
.leaflet-marker-pane,
.leaflet-marker-pane *,
.leaflet-marker-icon,
.leaflet-marker-icon * {
    overflow: visible !important;
}
        
        .auto-detect-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #1976d2;
        }

/* ===== STYLES DÉDIÉS COMPARAISON ===== */

.comparison-selects {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-bottom: 15px;
}

.comparison-label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--text-primary);
}

.comparison-select {
    width: 100%;
    padding: 8px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 1rem;
    background: var(--bg-card);
    color: var(--text-primary);
}

.comparison-select-best {
    border-color: #4caf50;
    background: #e8f5e9;
}

[data-theme="dark"] .comparison-select-best {
    background: #1b4d1b;
}

.comparison-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.replay-btn.btn-clear {
    background: linear-gradient(45deg, #f44336, #e91e63);
}

.comparison-legend {
    display: none;
    margin-top: 15px;
    padding: 10px;
    background: var(--bg-card);
    border-radius: 5px;
}

.legend-items {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    margin-top: 5px;
}

/* ===== MODE SOMBRE ===== */

[data-theme="dark"] .comparison-controls {
    background: #2d2d2d !important;
    border-left-color: #ff9800 !important;
}

[data-theme="dark"] .comparison-controls h4 {
    color: #ffb74d !important;
}

[data-theme="dark"] .comparison-controls p {
    color: var(--text-secondary) !important;
}

[data-theme="dark"] .comparison-controls label {
    color: var(--text-primary) !important;
}

[data-theme="dark"] .comparison-controls select {
    background: var(--bg-card) !important;
    color: var(--text-primary) !important;
    border-color: var(--border-color) !important;
}

[data-theme="dark"] .auto-detect-box {
    background: #2d2d2d !important;
    border-left-color: #64b5f6 !important;
}

[data-theme="dark"] .auto-detect-box h4 {
    color: #64b5f6 !important;
}

[data-theme="dark"] .auto-detect-box p {
    color: var(--text-secondary) !important;
}

[data-theme="dark"] #comparison-legend {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

[data-theme="dark"] #comparison-legend strong {
    color: var(--text-primary);
}

[data-theme="dark"] .replay-btn {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
}

[data-theme="dark"] .replay-btn:hover {
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.8);
}

.circuit-modal-content {
    background: var(--bg-card);
    color: var(--text-primary);
}

.circuit-modal-title {
    color: var(--accent);
}

.circuit-modal-desc {
    color: var(--text-secondary);
}

.circuit-section-title {
    color: var(--accent);
    border-bottom-color: var(--accent) !important;
}

.circuit-modal-item {
    background: var(--bg-card);
    border-color: var(--border-color) !important;
    color: var(--text-primary);
}

.circuit-modal-item:hover {
    background: var(--bg-secondary) !important;
    border-color: var(--accent) !important;
}

.circuit-modal-location {
    color: var(--text-secondary);
}

.circuit-modal-item.karting {
    border-color: #ff9800 !important;
}

.circuit-modal-item.karting:hover {
    background: var(--bg-secondary) !important;
}

/* ===== RESPONSIVE MOBILE ===== */
        
@media (max-width: 768px) {
    .stats-grid { 
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .stat-card {
        padding: 15px;
    }
    
    .stat-value {
        font-size: 1.5rem;
    }
    
    .stat-label {
        font-size: 0.7rem;
    }
    
    .session-header { 
        flex-direction: column; 
        text-align: center; 
    }
    
    .session-info h2 {
        font-size: 1.2rem;
    }
    
    .header h1 { 
        font-size: 1.8rem; 
    }
    
    .container { 
        padding: 15px;
    }
    
    .map-container, #map { 
        height: 400px; 
        min-height: 400px; 
    }
    
    table {
        font-size: 0.75rem;
    }
    
    table th, table td {
        padding: 6px 4px;
    }
    
    .tab {
        padding: 10px 12px;
        font-size: 0.85rem;
    }
    
    .analysis-card {
        padding: 15px;
    }
    
    .analysis-card h4 {
        font-size: 1rem;
    }
    
    .analysis-grid {
        grid-template-columns: 1fr;
    }
    
    
    
    .turns-grid {
        grid-template-columns: 1fr;
    }
    
    .chart-container {
        padding: 15px 10px;
    }
    
    .chart-container canvas {
        max-height: 300px;
        min-height: 200px;
    }
    
    .chart-container h4 {
        font-size: 0.95rem;
        margin-bottom: 10px;
    }

    .theme-toggle {
        top: 10px;
        right: 10px;
        padding: 8px 15px;
        font-size: 1rem;
    }
    
    .theme-toggle-icon {
        font-size: 1.3rem;
    }

    .comparison-controls {
        padding: 15px;
    }
    
    .comparison-controls h4 {
        font-size: 1rem;
    }
    
    .comparison-controls p {
        font-size: 0.85rem;
    }

    .comparison-selects {
        grid-template-columns: 1fr !important;
        gap: 12px !important;
    }
    
    .comparison-select {
        font-size: 0.9rem !important;
        padding: 10px !important;
    }
    
    .comparison-buttons {
        flex-direction: column !important;
        gap: 8px !important;
    }
    
    .comparison-buttons .replay-btn {
        width: 100% !important;
    }

    #comparison-legend {
        padding: 10px;
        font-size: 0.85rem;
    }
    
    .legend-items {
        flex-direction: column !important;
        gap: 10px !important;
    }
    
    .circuit-info {
        flex-direction: column;
        text-align: center;
        padding: 15px;
        gap: 10px;
    }
    
    .circuit-icon {
        font-size: 2.5rem;
    }
    
    .circuit-details h4 {
        font-size: 1.1rem;
    }
    
    .circuit-details p {
        font-size: 0.9rem;
    }
    
    .auto-detect-box {
        padding: 15px;
    }
    
    .auto-detect-box h4 {
        font-size: 1rem;
    }
    
    .auto-detect-box p {
        font-size: 0.85rem;
    }
    
    .auto-detect-box .replay-btn {
        width: 100%;
        padding: 12px;
        font-size: 0.9rem;
    }
    
    .map-controls {
        justify-content: center;
    }
    
    .map-controls button {
        flex: 1;
        min-width: 120px;
        padding: 10px 12px;
        font-size: 0.85rem;
    }
      
    
    
    
    .replay-controls {
        padding: 15px;
    }
    
    .replay-info {
        font-size: 0.85rem;
        margin-bottom: 10px;
    }
    
    .replay-slider {
        margin: 10px 0;
    }
    
    .replay-buttons {
        gap: 8px;
    }
    
    .replay-btn {
        padding: 10px 15px;
        font-size: 0.85rem;
        flex: 1;
        min-width: 80px;
    }

    #track-content * {
        max-width: 100%;
        box-sizing: border-box;
    }
    
    #track-content .tab-content {
        overflow-x: hidden;
    }
    
    #track-content > * {
        padding-left: 10px;
        padding-right: 10px;
    }
    
    #track-content .map-container {
        padding: 0;
        margin-left: 10px;
        margin-right: 10px;
    }

    [data-theme="dark"] select {
        color-scheme: dark;
    }
}

/* ===== TRÈS PETITS ÉCRANS ===== */
@media (max-width: 375px) {
    .comparison-controls {
        padding: 12px;
    }
    
    .comparison-controls h4 {
        font-size: 0.95rem;
    }
    
    .circuit-info {
        padding: 12px;
    }
    
    .circuit-icon {
        font-size: 2rem;
    }
    
    .map-controls button {
        min-width: 100px;
        padding: 8px 10px;
        font-size: 0.8rem;
    }
    
    .track-stats {
        gap: 8px;
    }
    
    .track-stat-card {
        padding: 10px;
    }
    
    .replay-btn {
        padding: 8px 12px;
        font-size: 0.8rem;
        min-width: 70px;
    }

    .comparison-select {
        font-size: 0.85rem !important;
        padding: 8px !important;
    }
}

/* ===== MODE PAYSAGE MOBILE ===== */
@media (max-width: 900px) and (orientation: landscape) {
    .container {
        padding: 10px;
    }
    
    .stats-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
    }
    
    .stat-card {
        padding: 10px;
    }
    
    .stat-value {
        font-size: 1.3rem;
    }
    
    .stat-label {
        font-size: 0.65rem;
    }
    
    .map-container, #map {
        height: 300px;
        min-height: 300px;
    }
    
    .header {
        padding: 15px;
    }
    
    .header h1 {
        font-size: 1.5rem;
    }
    
    table {
        font-size: 0.7rem;
    }

    .comparison-controls {
        padding: 10px;
    }
    
    .comparison-controls h4 {
        font-size: 0.9rem;
        margin-bottom: 5px;
    }
    
    .comparison-controls p {
        font-size: 0.75rem;
        margin-bottom: 10px;
    }
    
    .circuit-info {
        padding: 10px;
        flex-direction: row;
        gap: 10px;
    }
    
    .circuit-icon {
        font-size: 2rem;
    }
    
    .circuit-details h4 {
        font-size: 0.95rem;
        margin-bottom: 3px;
    }
    
    .circuit-details p {
        font-size: 0.8rem;
    }
    
    .map-controls button {
        padding: 6px 10px;
        font-size: 0.8rem;
    }
    
        
    .replay-controls {
        padding: 10px;
    }
    
    .replay-info {
        font-size: 0.8rem;
    }
    
    .replay-btn {
        padding: 6px 12px;
        font-size: 0.8rem;
    }

    .comparison-select option:disabled {
    color: #999;
    font-style: italic;
}

[data-theme="dark"] .comparison-select option:disabled {
    color: #666;
}
}
/* ===== FIX SPÉCIFIQUE ONGLET CIRCUIT - MOBILE ===== */

@media (max-width: 768px) {
    /* FORCER la mise en page responsive pour la comparaison */
    #track-content .comparison-controls > div[style] {
        display: flex !important;
        flex-direction: column !important;
        grid-template-columns: unset !important;
        gap: 12px !important;
        margin-bottom: 12px !important;
    }
    
    /* Forcer les boutons en colonne */
    #track-content .comparison-controls > div[style*="flex"] {
        flex-direction: column !important;
        flex-wrap: nowrap !important;
        gap: 8px !important;
    }
    
    /* S'assurer que les replay-btn prennent toute la largeur */
    #track-content .comparison-controls .replay-btn {
        width: 100% !important;
        max-width: none !important;
        flex: none !important;
    }
    
    /* Selects en pleine largeur */
    #track-content .comparison-controls select {
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
    }
    
    /* Labels en block */
    #track-content .comparison-controls label {
        display: block !important;
        width: 100% !important;
    }
    
    /* Conteneur parent des selects */
    #track-content .comparison-controls > div > div {
        width: 100% !important;
    }
    
    /* Circuit info en colonne */
    #track-content .circuit-info {
        flex-direction: column !important;
        text-align: center !important;
    }
    
    /* Auto detect box - bouton pleine largeur */
    #track-content .auto-detect-box .replay-btn {
        width: 100% !important;
        max-width: none !important;
    }
    
    /* Map controls */
    #track-content .map-controls {
        display: flex !important;
        flex-wrap: wrap !important;
    }
    
    #track-content .map-controls button {
        flex: 1 1 calc(50% - 5px) !important;
        min-width: 120px !important;
    }
    
    /* Replay buttons */
    #track-content .replay-buttons {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 8px !important;
    }
    
    #track-content .replay-buttons .replay-btn {
        flex: 1 1 calc(50% - 4px) !important;
        min-width: 100px !important;
    }
    
    /* Legend items en colonne */
    #track-content #legend-items {
        display: flex !important;
        flex-direction: column !important;
        gap: 10px !important;
    }
    
    
}

/* Très petits écrans */
@media (max-width: 375px) {
    #track-content .replay-buttons .replay-btn {
        flex: 1 1 100% !important;
        width: 100% !important;
    }
    
    #track-content .map-controls button {
        flex: 1 1 100% !important;
        width: 100% !important;
    }
}

/* Mode paysage */
@media (max-width: 900px) and (orientation: landscape) {
    #track-content .comparison-controls > div[style] {
        flex-direction: row !important;
        gap: 10px !important;
    }
    
    #track-content .comparison-controls > div[style] > div {
        flex: 1 !important;
    }
    
   
}
/* Fix général pour éviter les débordements */
@media (max-width: 768px) {
    #track-content * {
        max-width: 100%;
        box-sizing: border-box;
    }
    
    #track-content .tab-content {
        overflow-x: hidden;
    }
    
    /* Padding latéral pour tout le contenu */
    #track-content > * {
        padding-left: 10px;
        padding-right: 10px;
    }
    
    /* Sauf la carte qui a déjà son conteneur */
    #track-content .map-container {
        padding: 0;
        margin-left: 10px;
        margin-right: 10px;
    }
}
/* ===== STYLES DÉDIÉS COMPARAISON (remplace inline) ===== */

.comparison-selects {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-bottom: 15px;
}

.comparison-label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--text-primary);
}

.comparison-select {
    width: 100%;
    padding: 8px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 1rem;
    background: var(--bg-card);
    color: var(--text-primary);
}

.comparison-select-best {
    border-color: #4caf50;
    background: #e8f5e9;
}

[data-theme="dark"] .comparison-select-best {
    background: #1b4d1b;
}

.comparison-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.replay-btn.btn-clear {
    background: linear-gradient(45deg, #f44336, #e91e63);
}

/* ===== RESPONSIVE COMPARAISON ===== */
@media (max-width: 768px) {
    .comparison-selects {
        grid-template-columns: 1fr !important;
        gap: 12px !important;
    }
    
    .comparison-select {
        font-size: 0.9rem !important;
        padding: 10px !important;
    }
    
    .comparison-buttons {
        flex-direction: column !important;
        gap: 8px !important;
    }
    
    .comparison-buttons .replay-btn {
        width: 100% !important;
    }
}

@media (max-width: 375px) {
    .comparison-select {
        font-size: 0.85rem !important;
        padding: 8px !important;
    }
}
/* Fix général pour éviter les débordements */
@media (max-width: 768px) {
    #track-content * {
        max-width: 100%;
        box-sizing: border-box;
    }
    
    #track-content .tab-content {
        overflow-x: hidden;
    }
    
    /* Padding latéral pour tout le contenu */
    #track-content > * {
        padding-left: 10px;
        padding-right: 10px;
    }
    
    /* Sauf la carte qui a déjà son conteneur */
    #track-content .map-container {
        padding: 0;
        margin-left: 10px;
        margin-right: 10px;
    }

/* ===== CONTENEURS BLUETOOTH ===== */
.bluetooth-container {
    background: var(--bg-card);
    padding: 30px;
    border-radius: 15px;
    max-width: 600px;
    margin: 0 auto;
}

.instructions-box {
    margin-top: 20px;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 4px solid var(--accent);
}

.instructions-title {
    margin: 0;
    font-size: 0.9rem;
    color: var(--accent);
}

.instructions-list {
    margin: 10px 0 0 0;
    padding-left: 20px;
    font-size: 0.85rem;
    color: var(--text-primary);
}

/* Titres dans les pages Bluetooth */
#esp32-page h2,
#settings-page h2 {
    color: var(--accent);
}

#esp32-page p,
#settings-page p {
    color: var(--text-secondary);
}
   .export-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    color: white;
    transition: all 0.3s ease;
    font-size: 1rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.export-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.export-btn:active {
    transform: translateY(-1px);
}   

/* Texte DANS la barre colorée (toujours blanc) */
.progress-bar-text-inside {
    color: white !important;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    position: relative;
    z-index: 1;
}

/* Texte HORS de la barre colorée (toujours noir) */
.progress-bar-text-outside {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.85rem;
    font-weight: bold;
    white-space: nowrap;
    color: #333333 !important;
}


}
            
    </style>
</head>
<body>
     <!-- Bouton mode sombre -->
    
    
    <div class="home-header">
    <div class="home-header">
    <div class="app-logo">
        <img src="./grthead.png" alt="GRT Logo">
    </div>   
</div>
    
    <div class="container">
    <!-- PAGE D'ACCUEIL -->
    <div id="home-page">
        <div class="welcome-section">
            
        </div>
        <!-- Toggle mode sombre -->
        <div class="theme-toggle-container">
            <span class="theme-toggle-label">Mode sombre</span>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Changer de thème" id="theme-toggle-btn"></button>
        </div>

        <!-- Option 1: GPS_LapTimer -->
        <div class="connection-card" onclick="showESP32Mode()">
            <div class="connection-icon">🛜</div>
            <div>
                <h3>GPS_LapTimer</h3>
                <p>Se connecter au chronomètre GPS via Bluetooth</p>
            </div>
        </div>
        
        <!-- Option 2: Fichier Local -->
        <div class="connection-card" onclick="showLocalFileMode()">
            <div class="connection-icon">📁</div>
            <div>
                <h3>Fichier Local</h3>
                <p>Importer un fichier JSON depuis votre appareil</p>
            </div>
        </div>
        
        <!-- Option 3: Sessions Sauvegardées -->
        <div class="connection-card" onclick="showStoredFiles()" id="stored-files-card">
            <div class="connection-icon">💾</div>
            <div>
                <h3>Sessions Sauvegardées</h3>
                <p id="stored-count">Aucune session</p>
            </div>
        </div>

        <div class="connection-card" onclick="showSettingsPage()">
        <div class="connection-icon">⚙️</div>
        <div>
            <h3>Paramètres</h3>
            <p>Configurer le chronomètre GPS via Bluetooth</p>
        </div>
    </div>


    </div>
    
    <!-- MODE FICHIER LOCAL -->
    <div class="upload-area" id="upload-area" style="display: none;">
        <button class="back-button" onclick="returnToHome()">← Retour</button>
        <div class="upload-icon">📁</div>
        <h3>Glissez-deposez votre fichier JSON</h3>
        <p>ou cliquez pour selectionner</p>
        <input type="file" id="file-input" accept=".json" style="display: none;">
    </div>
    
    <!-- MODE GPS_LAPTIMER BLUETOOTH -->
    <div id="esp32-page" style="display: none;">
        <button class="back-button" onclick="returnToHome()">← Retour</button>
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="color: #1976d2;">🔵 Connexion GPS_LapTimer Bluetooth</h2>
            <p style="color: #666; margin-top: 10px;">Utilisez Chrome ou Edge</p>
        </div>
        
        <div class="bluetooth-container">
            <div id="esp32-status" style="padding: 15px; border-radius: 8px; margin: 20px 0; display: none;"></div>
            
            <button onclick="connectESP32()" style="width: 100%; padding: 15px; background: linear-gradient(45deg, #1976d2, #42a5f5); color: white; border: none; border-radius: 8px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                🔗 Connexion Bluetooth
            </button>
            
            <div class="instructions-box">
    <p class="instructions-title"><strong>Instructions :</strong></p>
    <ol class="instructions-list">
                    <li>Allumez le GPS_LapTimer</li>
                    <li>Activez le Bluetooth sur votre appareil</li>
                    <li>Cliquez sur "Connexion Bluetooth"</li>
                    <li>Sélectionnez "GPS_Chrono_GRT" dans la liste</li>
                </ol>
            </div>
            
            <div id="esp32-files-list" style="margin-top: 30px; display: none;">
                <h3 style="color: #1976d2; margin-bottom: 15px;">📂 Sessions Disponibles</h3>
                <div id="esp32-files-container"></div>
            </div>
        </div>
    </div>
    
    <!-- LISTE DES FICHIERS STOCKÉS -->
    <div id="stored-files-page" style="display: none;">
        <button class="back-button" onclick="returnToHome()">← Retour</button>
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="color: #1976d2;">💾 Sessions Sauvegardées</h2>
        </div>
        
        <div style="max-width: 800px; margin: 0 auto 20px auto; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
            <button id="toggle-select-btn" onclick="toggleSelectAll()" style="padding: 10px 20px; background: #2196f3; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
    ☑️ Tout sélectionner
</button>
            <button id="download-selected-btn" onclick="downloadSelectedSessions()" style="padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; display: none;">
                📥 Télécharger (<span id="selected-count">0</span>)
            </button>
        </div>
        
        <div id="stored-files-list" style="max-width: 800px; margin: 0 auto;"></div>
        
        <div style="text-align: center; margin-top: 30px;">
            <button onclick="clearAllSessions()" style="padding: 12px 25px; background: #f44336; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                🗑️ Supprimer Toutes les Sessions
            </button>
        </div>
    </div>


    <div id="settings-page" style="display: none;">
        <button class="back-button" onclick="returnToHome()">← Retour</button>
        <div style="text-align: center; margin-bottom: 30px;">
            <h2 style="color: #1976d2;">⚙️ Paramètres GPS LapTimer</h2>
        </div>
        
        <div class="bluetooth-container">
            <!-- État connexion -->
            <div id="settings-status" style="padding: 15px; border-radius: 8px; margin: 20px 0; display: none;"></div>
            
            <!-- Bouton connexion -->
            <button id="settings-connect-btn" onclick="connectForSettings()" 
                    style="width: 100%; padding: 15px; background: linear-gradient(45deg, #1976d2, #42a5f5); 
                           color: white; border: none; border-radius: 8px; font-size: 1.1rem; 
                           font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 20px;">
                🔗 Connexion Bluetooth
            </button>
            
            <!-- Formulaire paramètres -->
            <div id="settings-form" style="display: none;">
                <h3 style="color: #1976d2; margin-bottom: 20px;">Configuration</h3>
                
                <div class="form-group">
                    <label for="param-lineHalfWidth">
                        <strong>Largeur ligne (m)</strong>
                        <br><small style="color: #666;">Largeur de détection de la ligne d'arrivée</small>
                    </label>
                    <input type="number" id="param-lineHalfWidth" step="0.1" min="10" max="100"
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 1rem;">
                </div>
                
                <div class="form-group">
                    <label for="param-defineLineSpeed">
                        <strong>Vitesse déclenchement (km/h)</strong>
                        <br><small style="color: #666;">Vitesse minimale pour définir la ligne de départ</small>
                    </label>
                    <input type="number" id="param-defineLineSpeed" step="0.1" min="10" max="100"
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 1rem;">
                </div>
                
                <div class="form-group">
                    <label for="param-ctrlSpeed">
                        <strong>Vitesse contrôle (km/h)</strong>
                        <br><small style="color: #666;">Vitesse minimale pour détecter un passage de ligne</small>
                    </label>
                    <input type="number" id="param-ctrlSpeed" step="0.1" min="10" max="100"
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 1rem;">
                </div>
                
                <div class="form-group">
                    <label for="param-stopSpeed">
                        <strong>Vitesse arrêt (km/h)</strong>
                        <br><small style="color: #666;">Vitesse en dessous de laquelle le chrono s'arrête</small>
                    </label>
                    <input type="number" id="param-stopSpeed" step="0.1" min="0" max="20"
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 1rem;">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 30px;">
                    <button onclick="saveSettings()" 
                            style="flex: 1; padding: 12px; background: #4caf50; color: white; 
                                   border: none; border-radius: 8px; font-weight: bold; cursor: pointer;">
                        💾 Sauvegarder
                    </button>
                    <button onclick="loadCurrentSettings()" 
                            style="flex: 1; padding: 12px; background: #ff9800; color: white; 
                                   border: none; border-radius: 8px; font-weight: bold; cursor: pointer;">
                        🔄 Recharger
                    </button>
                </div>
            </div>
            
            <!-- Instructions -->
            <div class="instructions-box">
    <p class="instructions-title"><strong>Instructions :</strong></p>
    <ol class="instructions-list">
                    <li>Allumez le GPS LapTimer</li>
                    <li>Activez le Bluetooth</li>
                    <li>Cliquez sur "Connexion Bluetooth"</li>
                    <li>Modifiez les paramètres souhaités</li>
                    <li>Cliquez sur "Sauvegarder"</li>
                </ol>
            </div>
        </div>
    </div>
    
       <div id="session-content">
            <div class="session-header">
                <div class="session-info">
                    <h2 id="session-title">Session Circuit</h2>
                    <div class="session-date" id="session-date"></div>
                </div>
                <div class="session-badge" id="session-badge"></div> 
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="stat-laps">-</div>
                    <div class="stat-label">Tours Termines</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-best">-</div>
                    <div class="stat-label">Meilleur Temps</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-maxspeed">-</div>
                    <div class="stat-label">Vitesse Max (km/h)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-avgspeed">-</div>
                    <div class="stat-label">Vitesse Moy (km/h)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-distance">-</div>
                    <div class="stat-label">Distance (km)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-total">-</div>
                    <div class="stat-label">Temps Total</div>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" onclick="showTab('laps')">Tours</button>
                <button class="tab" onclick="showTab('track')">Circuit</button>
                <button class="tab" onclick="showTab('analysis')">Analyse</button>
                <button class="tab" onclick="showTab('progression')">Progression</button>
                <button class="tab" onclick="showTab('turns')">Virages</button>
                <button class="tab" onclick="showTab('export')">Export</button>
            </div>
            
            <div id="laps-content" class="tab-content active">
                <table id="laps-table">
                    <thead>
                        <tr>
                            <th>Tour</th>
                            <th>Temps</th>
                            <th>Ecart</th>
                            <th>V.Max</th>
                            <th>V.Moy</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            
            <div id="track-content" class="tab-content">
             <div class="comparison-controls">
    <h4 style="margin-bottom: 10px; color: #ff6f00;">Visualisation des Tours</h4>
    
    <!-- MODE AFFICHAGE SIMPLE -->
    <div id="single-lap-mode" style="margin-bottom: 20px;">
        <p style="margin-bottom: 10px; font-size: 0.9rem;">Afficher un tour individuel</p>
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 200px;">
                <label class="comparison-label">Sélectionner un tour</label>
                <select id="single-lap-selector" class="comparison-select">
                    <option value="">-- Sélectionner --</option>
                </select>
            </div>
            <button class="replay-btn" onclick="displaySelectedSingleLap()" style="margin-top: 20px;">
                📊 Afficher ce Tour
            </button>
        </div>
    </div>
    
    <div style="border-top: 2px solid var(--border-color); margin: 20px 0;"></div>
    
    <!-- MODE COMPARAISON -->
    <div id="comparison-mode">
        <p style="margin-bottom: 10px; font-size: 0.9rem;">Comparer deux tours</p>
        <div class="comparison-selects">
            <div>
                <label class="comparison-label">Tour 1</label>
                <select id="compare-lap1" class="comparison-select">
                    <option value="">-- Sélectionner --</option>
                </select>
            </div>
            <div>
                <label class="comparison-label">Tour 2</label>
                <select id="compare-lap2" class="comparison-select">
                    <option value="">-- Sélectionner --</option>
                </select>
            </div>
        </div>

        <div class="comparison-buttons">
            <button class="replay-btn" onclick="compareSelectedLaps()">Comparer les Tours</button>
            <button class="replay-btn btn-clear" onclick="clearComparison()">Réinitialiser</button>
        </div>
    </div>
    
    <div id="comparison-legend" class="comparison-legend">
        <strong>Légende:</strong>
        <div id="legend-items" class="legend-items"></div>
    </div>
</div>   

                <div class="auto-detect-box" id="circuit-unknown" style="display: none;">
    <h4 style="margin-bottom: 10px;">Circuit Non Identifié</h4>
    <p style="margin-bottom: 15px;">Ce circuit n'est pas dans la base de données des 155 circuits français.</p>
    <button class="replay-btn" style="background: linear-gradient(45deg, #9c27b0, #ba68c8);" 
            onclick="showAllCircuits()">Sélectionner manuellement</button>
</div>
                
                <div class="circuit-info" id="circuit-info" style="display: none;">
                    <div class="circuit-icon"></div>
                    <div class="circuit-details">
                        <h4 id="circuit-name">Circuit detecte</h4>
                        <p id="circuit-location"></p>
                    </div>
                </div>
                
                
                
                <div class="map-controls">
                    <button style="background: #2196f3; color: white;" onclick="switchMapView('satellite')">Vue Satellite</button>
                    <button style="background: #4caf50; color: white;" onclick="switchMapView('street')">Vue Route</button>
                </div>
                
                <div class="map-container">
                    <div id="map"></div>
                </div>
                
                <div class="replay-controls" id="replay-controls-circuit">
                    <div class="replay-info" id="replay-info-circuit">
                        Temps: <span id="replay-time-circuit">0.0s</span> | 
                        Vitesse: <span id="replay-speed-circuit">0 km/h</span> | 
                        Position: <span id="replay-position-circuit">0/0</span>
                    </div>
                    
                    <input type="range" class="replay-slider" id="replay-slider-circuit" min="0" max="100" value="0">
                    
                    
                </div>
                
                
                
                <div class="chart-container" id="speed-chart-container">
                    <h4 style="margin-bottom: 15px; color: #1976d2;">Evolution de la Vitesse</h4>
                    <canvas id="speed-chart"></canvas>
                </div>
                
                <div class="track-stats">
                    <div class="track-stat-card">
                        <div class="track-stat-value" id="track-points">-</div>
                        <div class="track-stat-label">Points GPS</div>
                    </div>
                    <div class="track-stat-card">
                        <div class="track-stat-value" id="track-distance">-</div>
                        <div class="track-stat-label">Distance parcourue</div>
                    </div>
                    <div class="track-stat-card">
                        <div class="track-stat-value" id="track-minspeed">-</div>
                        <div class="track-stat-label">Vitesse min</div>
                    </div>
                    <div class="track-stat-card">
                        <div class="track-stat-value" id="track-maxspeed">-</div>
                        <div class="track-stat-label">Vitesse max</div>
                    </div>
                </div>
            </div>
            
            <div id="analysis-content" class="tab-content">
                <div class="analysis-grid" id="analysis-grid"></div>
            </div>
            
            <div id="progression-content" class="tab-content">
                <div class="progress-bars" id="progress-bars"></div>
            </div>
            
            <div id="turns-content" class="tab-content">
                <h3 style="margin-bottom: 20px; color: #1976d2;">Analyse Detaillee des Virages</h3>
                <div class="turns-grid" id="turns-grid"></div>
            </div>
            
            <div id="export-content" class="tab-content">
    <div class="export-section">
        <h3 style="margin-bottom: 15px; color: #1976d2;">Exporter les Données</h3>
        <p style="color: #666; margin-bottom: 20px;">Téléchargez vos données dans différents formats</p>
        
        <div class="export-buttons">
            <button class="export-btn" style="background: #4caf50;" onclick="exportData('csv')">
                📊 Export CSV
            </button>
            <button class="export-btn" style="background: #2196f3;" onclick="exportData('gpx')">
                📍 Export GPX
            </button>
            <button class="export-btn" style="background: #f44336;" onclick="exportToPDF()">
                📄 Export PDF
            </button>
            <button class="export-btn" style="background: #9c27b0;" onclick="exportData('telemetry')">
                📡 Télémétrie Complète
            </button>
        </div>
        
        
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        let sessionData = null;
        let map = null;
        let gpsLayer = null;
        let currentMapView = 'satellite';
        let replayMarker = null;
        let replayInterval = null;
        let replaySpeed = 1;
        let replayIndex = 0;
        let speedChart = null;
        let comparisonLayers = [];
        let lapSegments = [];
        let comparisonChart = null;
        let isComparisonMode = false;
        let currentReplayData = null;
        let currentSessionId = null;
        let bluetoothDevice = null;
        let bluetoothCharacteristic = null;
        let bleDataBuffer = "";
        let isReceivingFile = false;
        let expectedFileSize = 0;
        let receivedFileData = "";

        const SERVICE_UUID = "0000ffe0-0000-1000-8000-00805f9b34fb";
        const CHARACTERISTIC_UUID = "0000ffe1-0000-1000-8000-00805f9b34fb";

        let settingsBluetoothDevice = null;
        let settingsBluetoothCharacteristic = null;
        let currentConfig = {};

        


// ========== GESTION MODE SOMBRE ==========
function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    
    updateThemeToggle(newTheme);
    applyPageTheme();
}

function updateThemeToggle(theme) {
    const toggle = document.getElementById('theme-toggle-btn');
    if (toggle) {
        toggle.setAttribute('data-theme', theme);
    }
}

function initTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeToggle(savedTheme);
    applyPageTheme();
}

// Initialiser le thème au chargement
window.addEventListener('DOMContentLoaded', () => {
    initTheme(); // ← TRÈS IMPORTANT
    updateStoredFilesCount();
    updateThemeButtonVisibility(true);
    
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    
    
});


        // BASE DE DONNÉES COMPLÈTE - 155 CIRCUITS OUTDOOR FRANCE
const CIRCUITS_DATABASE = [
    
    // ==========================================
    // CIRCUITS AUTOMOBILE (33)
    // ==========================================
    
    // Île-de-France (3)
    { name: "Circuit Carole", location: "Aulnay-sous-Bois, Île-de-France", 
      lat: 48.9534, lng: 2.4847, radius: 2000, length: 1.814, type: "auto" },
    { name: "Autodrome de Linas-Montlhéry", location: "Linas, Île-de-France", 
      lat: 48.6428, lng: 2.2669, radius: 3000, length: 2.548, type: "auto" },
    { name: "La Ferté-Gaucher", location: "La Ferté-Gaucher, Île-de-France", 
      lat: 48.7808, lng: 3.3072, radius: 2000, length: 2.800, type: "auto" },
    
    // Hauts-de-France (4)
    { name: "Croix-en-Ternois", location: "Croix-en-Ternois, Hauts-de-France", 
      lat: 50.3456, lng: 2.2347, radius: 2000, length: 2.500, type: "auto" },
    { name: "Clastres", location: "Clastres, Hauts-de-France", 
      lat: 49.7414, lng: 3.2086, radius: 2000, length: 2.780, type: "auto" },
    { name: "Circuit des Écuyers", location: "Beuvardes, Hauts-de-France", 
      lat: 49.1073, lng: 3.5069, radius: 2000, length: 2.750, type: "auto" },
    { name: "Folembray", location: "Folembray, Hauts-de-France", 
      lat: 49.6692, lng: 3.4647, radius: 1500, length: 2.080, type: "auto" },
    
    // Bourgogne-Franche-Comté (4)
    { name: "Magny-Cours", location: "Nevers, Bourgogne-Franche-Comté", 
      lat: 46.8642, lng: 3.1633, radius: 3000, length: 4.411, type: "auto" },
    { name: "Dijon-Prenois", location: "Prenois, Bourgogne-Franche-Comté", 
      lat: 47.3628, lng: 4.8997, radius: 2500, length: 3.801, type: "auto" },
    { name: "Mornay", location: "Mornay, Bourgogne-Franche-Comté", 
      lat: 46.3753, lng: 4.6253, radius: 1500, length: 2.100, type: "auto" },
    { name: "Bresse", location: "Saint-Marcel, Bourgogne-Franche-Comté", 
      lat: 46.5261, lng: 5.3603, radius: 2000, length: 3.100, type: "auto" },
    
    // Provence-Alpes-Côte d'Azur (2)
    { name: "Paul Ricard", location: "Le Castellet, PACA", 
      lat: 43.2506, lng: 5.7919, radius: 3000, length: 5.842, type: "auto" },
    { name: "Circuit du Var", location: "Le Luc, PACA", 
      lat: 43.3847, lng: 6.3881, radius: 2000, length: 3.800, type: "auto" },
    
    // Occitanie (5)
    { name: "Circuit de Lédenon", location: "Lédenon, Occitanie", 
      lat: 43.9211, lng: 4.5025, radius: 2000, length: 3.156, type: "auto" },
    { name: "Alès Cévennes", location: "Alès, Occitanie", 
      lat: 44.0678, lng: 4.0839, radius: 2000, length: 2.485, type: "auto" },
    { name: "Nogaro", location: "Nogaro, Occitanie", 
      lat: 43.7611, lng: -0.0314, radius: 2500, length: 3.636, type: "auto" },
    { name: "Albi", location: "Albi, Occitanie", 
      lat: 43.9147, lng: 2.1153, radius: 2000, length: 3.565, type: "auto" },
    { name: "Toulouse Francazal", location: "Toulouse, Occitanie", 
      lat: 43.5456, lng: 1.3678, radius: 1500, length: 2.680, type: "auto" },
    
    // Nouvelle-Aquitaine (6)
    { name: "Pau-Arnos", location: "Arnos, Nouvelle-Aquitaine", 
      lat: 43.4556, lng: -0.4489, radius: 2500, length: 3.030, type: "auto" },
    { name: "Bordeaux-Mérignac", location: "Mérignac, Nouvelle-Aquitaine", 
      lat: 44.8311, lng: -0.6889, radius: 2000, length: 2.529, type: "auto" },
    { name: "Val de Vienne", location: "Le Vigeant, Nouvelle-Aquitaine", 
      lat: 46.5733, lng: 0.6578, radius: 2500, length: 3.775, type: "auto" },
    { name: "Faleyras", location: "Faleyras, Nouvelle-Aquitaine", 
      lat: 44.7461, lng: -0.2578, radius: 1500, length: 1.900, type: "auto" },
    { name: "Lurcy-Lévis", location: "Lurcy-Lévis, Auvergne-Rhône-Alpes", 
      lat: 46.7386, lng: 2.9286, radius: 2500, length: 3.750, type: "auto" },
    { name: "Issoire", location: "Issoire, Auvergne-Rhône-Alpes", 
      lat: 45.5439, lng: 3.2769, radius: 2000, length: 3.100, type: "auto" },
    
    // Grand Est (3)
    { name: "Anneau du Rhin", location: "Biltzheim, Grand Est", 
      lat: 47.9536, lng: 7.3597, radius: 2500, length: 3.705, type: "auto" },
    { name: "Chambley", location: "Chambley, Grand Est", 
      lat: 49.0225, lng: 5.8803, radius: 2500, length: 3.750, type: "auto" },
    
    // Pays de la Loire (1)
    { name: "Bugatti Le Mans", location: "Le Mans, Pays de la Loire", 
      lat: 47.9561, lng: 0.2269, radius: 3000, length: 4.185, type: "auto" },
    
    // Centre-Val de Loire (3)
    { name: "Châteauroux", location: "Châteauroux, Centre-Val de Loire", 
      lat: 46.8597, lng: 1.7253, radius: 2500, length: 3.650, type: "auto" },
    { name: "Dreux", location: "Dreux, Centre-Val de Loire", 
      lat: 48.7531, lng: 1.3547, radius: 1500, length: 2.200, type: "auto" },
    { name: "Abbeville", location: "Abbeville, Hauts-de-France", 
      lat: 50.0981, lng: 1.8392, radius: 1500, length: 1.720, type: "auto" },
    
    // Belgique proche France (2)
    { name: "Mettet", location: "Mettet, Belgique (proche France)", 
      lat: 50.3206, lng: 4.6617, radius: 2500, length: 2.650, type: "auto" },
    { name: "Spa-Francorchamps", location: "Stavelot, Belgique (proche France)", 
      lat: 50.4372, lng: 5.9714, radius: 4000, length: 7.004, type: "auto" },
    
    // ==========================================
    // CIRCUITS KARTING (94)
    // ==========================================
    
    // Île-de-France (8)
    { name: "SODI Paris", location: "Rungis, Île-de-France", 
      lat: 48.7508, lng: 2.3528, radius: 1000, length: 1.150, type: "karting" },
    { name: "PK1 Brétigny", location: "Brétigny-sur-Orge, Île-de-France", 
      lat: 48.6042, lng: 2.3061, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting de Sénart", location: "Lieusaint, Île-de-France", 
      lat: 48.6267, lng: 2.5492, radius: 1000, length: 1.200, type: "karting" },
    { name: "Kart Ouest", location: "Trappes, Île-de-France", 
      lat: 48.7686, lng: 1.9958, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Cormeilles", location: "Cormeilles-en-Parisis, Île-de-France", 
      lat: 48.9753, lng: 2.1997, radius: 800, length: 1.080, type: "karting" },
    { name: "Racing Kart Dupré", location: "Évry, Île-de-France", 
      lat: 48.6272, lng: 2.4492, radius: 800, length: 0.960, type: "karting" },
    { name: "Karting des Fagnes", location: "Mariembourg, Île-de-France proche", 
      lat: 50.0894, lng: 4.5208, radius: 1000, length: 1.250, type: "karting" },
    { name: "Racing Kart de Mantes", location: "Mantes-la-Jolie, Île-de-France", 
      lat: 48.9867, lng: 1.7122, radius: 800, length: 1.100, type: "karting" },
    
    // Auvergne-Rhône-Alpes (12)
    { name: "Karting de Lyon", location: "Corbas, Auvergne-Rhône-Alpes", 
      lat: 45.6686, lng: 4.9022, radius: 1000, length: 1.200, type: "karting" },
    { name: "Outdoor Lyon Ouest", location: "L'Arbresle, Auvergne-Rhône-Alpes", 
      lat: 45.8353, lng: 4.6197, radius: 800, length: 1.050, type: "karting" },
    { name: "Racing Kart Corsa", location: "Chaponnay, Auvergne-Rhône-Alpes", 
      lat: 45.6231, lng: 4.9347, radius: 1000, length: 1.350, type: "karting" },
    { name: "Karting de Grenoble", location: "Saint-Quentin-sur-Isère, Auvergne-Rhône-Alpes", 
      lat: 45.2564, lng: 5.5539, radius: 1000, length: 1.280, type: "karting" },
    { name: "Karting Annecy", location: "Argonay, Auvergne-Rhône-Alpes", 
      lat: 45.9344, lng: 6.1478, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Saint-Étienne", location: "Andrézieux-Bouthéon, Auvergne-Rhône-Alpes", 
      lat: 45.5283, lng: 4.2636, radius: 800, length: 1.050, type: "karting" },
    { name: "Kart 01", location: "Bourg-en-Bresse, Auvergne-Rhône-Alpes", 
      lat: 46.2058, lng: 5.2272, radius: 800, length: 1.000, type: "karting" },
    { name: "Karting Chambéry", location: "La Ravoire, Auvergne-Rhône-Alpes", 
      lat: 45.5631, lng: 5.9656, radius: 800, length: 1.120, type: "karting" },
    { name: "Piste Kart 07", location: "Privas, Auvergne-Rhône-Alpes", 
      lat: 44.7356, lng: 4.5986, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Valence", location: "Alixan, Auvergne-Rhône-Alpes", 
      lat: 44.9769, lng: 5.0308, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Vichy", location: "Hauterive, Auvergne-Rhône-Alpes", 
      lat: 46.1092, lng: 3.4297, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Roanne", location: "Le Coteau, Auvergne-Rhône-Alpes", 
      lat: 46.0300, lng: 4.0886, radius: 700, length: 1.020, type: "karting" },
    
    // Nouvelle-Aquitaine (12)
    { name: "Karting de Lons", location: "Lons, Nouvelle-Aquitaine", 
      lat: 43.3167, lng: -0.4000, radius: 800, length: 1.100, type: "karting" },
    { name: "Speed Park Bordeaux", location: "Mérignac, Nouvelle-Aquitaine", 
      lat: 44.8497, lng: -0.6944, radius: 1000, length: 1.300, type: "karting" },
    { name: "Karting Saint-Junien", location: "Saint-Junien, Nouvelle-Aquitaine", 
      lat: 45.8881, lng: 0.8997, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Poitiers", location: "Chasseneuil-du-Poitou, Nouvelle-Aquitaine", 
      lat: 46.6536, lng: 0.3731, radius: 800, length: 1.080, type: "karting" },
    { name: "Karting La Rochelle", location: "Puilboreau, Nouvelle-Aquitaine", 
      lat: 46.1811, lng: -1.1136, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Bergerac", location: "Bergerac, Nouvelle-Aquitaine", 
      lat: 44.8528, lng: 0.4833, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Angoulême", location: "L'Isle-d'Espagnac, Nouvelle-Aquitaine", 
      lat: 45.6553, lng: 0.1522, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Pau", location: "Lescar, Nouvelle-Aquitaine", 
      lat: 43.3381, lng: -0.4253, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Bayonne", location: "Ondres, Nouvelle-Aquitaine", 
      lat: 43.5597, lng: -1.4564, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Limoges", location: "Bonnac-la-Côte, Nouvelle-Aquitaine", 
      lat: 45.8881, lng: 1.2333, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Brive", location: "Brive-la-Gaillarde, Nouvelle-Aquitaine", 
      lat: 45.1508, lng: 1.5331, radius: 700, length: 0.920, type: "karting" },
    { name: "Circuit de Karting du Val d'Argenton", location: "Argentonnay, Nouvelle-Aquitaine", 
      lat: 46.9886, lng: -0.4292, radius: 800, length: 1.050, type: "karting" },
    
    // Occitanie (10)
    { name: "Karting Toulouse", location: "Aussonne, Occitanie", 
      lat: 43.6814, lng: 1.3192, radius: 1000, length: 1.250, type: "karting" },
    { name: "Karting Montpellier", location: "Vendargues, Occitanie", 
      lat: 43.6553, lng: 3.9672, radius: 800, length: 1.150, type: "karting" },
    { name: "Karting Perpignan", location: "Alénya, Occitanie", 
      lat: 42.6453, lng: 2.9889, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Narbonne", location: "Narbonne, Occitanie", 
      lat: 43.1839, lng: 3.0036, radius: 700, length: 1.020, type: "karting" },
    { name: "Karting Nîmes", location: "Marguerittes, Occitanie", 
      lat: 43.8628, lng: 4.4439, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Carcassonne", location: "Carcassonne, Occitanie", 
      lat: 43.2131, lng: 2.3486, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Tarbes", location: "Séméac, Occitanie", 
      lat: 43.2281, lng: 0.1114, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Rodez", location: "Onet-le-Château, Occitanie", 
      lat: 44.3694, lng: 2.5764, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Béziers", location: "Villeneuve-lès-Béziers, Occitanie", 
      lat: 43.3275, lng: 3.2653, radius: 700, length: 1.050, type: "karting" },
    { name: "Karting Cahors", location: "Cahors, Occitanie", 
      lat: 44.4478, lng: 1.4403, radius: 700, length: 0.920, type: "karting" },
    
    // Pays de la Loire (8)
    { name: "RKC Le Mans", location: "Le Mans, Pays de la Loire", 
      lat: 47.9561, lng: 0.2269, radius: 1000, length: 1.382, type: "karting" },
    { name: "Karting Nantes", location: "Bouguenais, Pays de la Loire", 
      lat: 47.1778, lng: -1.6181, radius: 1000, length: 1.200, type: "karting" },
    { name: "Karting Angers", location: "Écouflant, Pays de la Loire", 
      lat: 47.5308, lng: -0.5297, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting La Roche-sur-Yon", location: "Mouilleron-le-Captif, Pays de la Loire", 
      lat: 46.7211, lng: -1.4444, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Laval", location: "Changé, Pays de la Loire", 
      lat: 48.0939, lng: -0.7925, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Saint-Nazaire", location: "Trignac, Pays de la Loire", 
      lat: 47.3231, lng: -2.1953, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Cholet", location: "Cholet, Pays de la Loire", 
      lat: 47.0586, lng: -0.8753, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Sablé", location: "Sablé-sur-Sarthe, Pays de la Loire", 
      lat: 47.8436, lng: -0.3311, radius: 700, length: 1.020, type: "karting" },
    
    // Provence-Alpes-Côte d'Azur (9)
    { name: "Karting Marseille", location: "Plan-de-Campagne, PACA", 
      lat: 43.4897, lng: 5.4331, radius: 1000, length: 1.250, type: "karting" },
    { name: "Karting Nice", location: "Carros, PACA", 
      lat: 43.7839, lng: 7.1864, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Toulon", location: "La Valette-du-Var, PACA", 
      lat: 43.1372, lng: 5.9842, radius: 800, length: 1.080, type: "karting" },
    { name: "Karting Avignon", location: "Sorgues, PACA", 
      lat: 44.0094, lng: 4.8728, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Gap", location: "Gap, PACA", 
      lat: 44.5592, lng: 6.0794, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Aix-en-Provence", location: "Venelles, PACA", 
      lat: 43.5950, lng: 5.4814, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Antibes", location: "Biot, PACA", 
      lat: 43.6286, lng: 7.0972, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Cannes", location: "Le Cannet, PACA", 
      lat: 43.5778, lng: 7.0186, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Fréjus", location: "Fréjus, PACA", 
      lat: 43.4331, lng: 6.7372, radius: 700, length: 1.020, type: "karting" },
    
    // Grand Est (7)
    { name: "Karting Strasbourg", location: "Ostwald, Grand Est", 
      lat: 48.5431, lng: 7.7139, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Mulhouse", location: "Sausheim, Grand Est", 
      lat: 47.7881, lng: 7.3764, radius: 800, length: 1.080, type: "karting" },
    { name: "Karting Reims", location: "Cormontreuil, Grand Est", 
      lat: 49.2181, lng: 4.0494, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Metz", location: "Augny, Grand Est", 
      lat: 49.0672, lng: 6.1208, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Nancy", location: "Tomblaine, Grand Est", 
      lat: 48.6831, lng: 6.2200, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Colmar", location: "Wintzenheim, Grand Est", 
      lat: 48.0722, lng: 7.2825, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Épinal", location: "Épinal, Grand Est", 
      lat: 48.1744, lng: 6.4500, radius: 700, length: 0.920, type: "karting" },
    
    // Hauts-de-France (8)
    { name: "Karting Lille", location: "Lezennes, Hauts-de-France", 
      lat: 50.6150, lng: 3.1150, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Amiens", location: "Rivery, Hauts-de-France", 
      lat: 49.9092, lng: 2.3231, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Valenciennes", location: "Rouvignies, Hauts-de-France", 
      lat: 50.3261, lng: 3.5403, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Dunkerque", location: "Grande-Synthe, Hauts-de-France", 
      lat: 51.0136, lng: 2.3019, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Calais", location: "Marck, Hauts-de-France", 
      lat: 50.9453, lng: 1.9556, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Arras", location: "Saint-Laurent-Blangy, Hauts-de-France", 
      lat: 50.3067, lng: 2.8089, radius: 700, length: 1.020, type: "karting" },
    { name: "Karting Beauvais", location: "Tillé, Hauts-de-France", 
      lat: 49.4614, lng: 2.1128, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Douai", location: "Lambres-lez-Douai, Hauts-de-France", 
      lat: 50.3542, lng: 3.0592, radius: 700, length: 0.920, type: "karting" },
    
    // Bretagne (7)
    { name: "Karting Rennes", location: "Chartres-de-Bretagne, Bretagne", 
      lat: 48.0439, lng: -1.7078, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Brest", location: "Gouesnou, Bretagne", 
      lat: 48.4506, lng: -4.4689, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Lorient", location: "Caudan, Bretagne", 
      lat: 47.8103, lng: -3.3364, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Vannes", location: "Ploeren, Bretagne", 
      lat: 47.6564, lng: -2.8636, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Saint-Brieuc", location: "Plérin, Bretagne", 
      lat: 48.5422, lng: -2.7278, radius: 700, length: 1.020, type: "karting" },
    { name: "Karting Quimper", location: "Pluguffan, Bretagne", 
      lat: 47.9767, lng: -4.1678, radius: 700, length: 0.920, type: "karting" },
    { name: "Circuit Nelly Delamarche", location: "Fougères, Bretagne", 
      lat: 48.3528, lng: -1.2006, radius: 700, length: 0.980, type: "karting" },
    
    // Normandie (13)
    { name: "Karting Rouen", location: "Eslettes, Normandie", 
      lat: 49.5683, lng: 1.3597, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Caen", location: "Carpiquet, Normandie", 
      lat: 49.1883, lng: -0.4531, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Le Havre", location: "Gonfreville-l'Orcher, Normandie", 
      lat: 49.5069, lng: 0.2278, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Alençon", location: "Valframbert, Normandie", 
      lat: 48.4578, lng: 0.1036, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Cherbourg", location: "La Glacerie, Normandie", 
      lat: 49.6158, lng: -1.6092, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Évreux", location: "Guichainville, Normandie", 
      lat: 49.0314, lng: 1.1850, radius: 700, length: 0.920, type: "karting" },
    { name: "Circuit Lucien Lebret", location: "Courseulles-sur-Mer, Normandie", 
      lat: 49.3275, lng: -0.4578, radius: 800, length: 1.080, type: "karting" },
    { name: "Circuit de Cabourg", location: "Cabourg, Normandie", 
      lat: 49.2867, lng: -0.1178, radius: 700, length: 0.950, type: "karting" },
    { name: "Circuit international d'Aunay les Bois", location: "Aunay-sur-Odon, Normandie", 
      lat: 49.0194, lng: -0.6272, radius: 1000, length: 1.200, type: "karting" },
    { name: "Circuit du Mortainais", location: "Mortain-Bocage, Normandie", 
      lat: 48.6472, lng: -0.9419, radius: 800, length: 1.050, type: "karting" },
    { name: "Circuit de la Hague", location: "Beaumont-Hague, Normandie", 
      lat: 49.6644, lng: -1.8364, radius: 700, length: 0.980, type: "karting" },
    { name: "Circuit de la Manche", location: "Saint-Lô, Normandie", 
      lat: 49.1153, lng: -1.0908, radius: 800, length: 1.100, type: "karting" },
    { name: "Circuit du Parc", location: "Granville, Normandie", 
      lat: 48.8378, lng: -1.5989, radius: 700, length: 0.920, type: "karting" },
    
    // Centre-Val de Loire (5)
    { name: "Karting Orléans", location: "Saint-Jean-de-Braye, Centre-Val de Loire", 
      lat: 47.9117, lng: 1.9731, radius: 800, length: 1.100, type: "karting" },
    { name: "Karting Tours", location: "Chambray-lès-Tours, Centre-Val de Loire", 
      lat: 47.3364, lng: 0.7178, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Bourges", location: "Saint-Doulchard, Centre-Val de Loire", 
      lat: 47.1006, lng: 2.3742, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Blois", location: "Vineuil, Centre-Val de Loire", 
      lat: 47.5831, lng: 1.3778, radius: 700, length: 0.980, type: "karting" },
    { name: "Karting Chartres", location: "Lucé, Centre-Val de Loire", 
      lat: 48.4344, lng: 1.4656, radius: 700, length: 0.920, type: "karting" },
    
    // Bourgogne-Franche-Comté (4)
    { name: "Karting Dijon", location: "Chenôve, Bourgogne-Franche-Comté", 
      lat: 47.2919, lng: 5.0047, radius: 800, length: 1.050, type: "karting" },
    { name: "Karting Besançon", location: "Pirey, Bourgogne-Franche-Comté", 
      lat: 47.2622, lng: 5.9725, radius: 700, length: 1.000, type: "karting" },
    { name: "Karting Auxerre", location: "Monéteau, Bourgogne-Franche-Comté", 
      lat: 47.8289, lng: 3.5703, radius: 700, length: 0.950, type: "karting" },
    { name: "Karting Belfort", location: "Andelnans, Bourgogne-Franche-Comté", 
      lat: 47.6092, lng: 6.8764, radius: 700, length: 0.980, type: "karting" },
    
    // Corse (2)
    { name: "Karting Ajaccio", location: "Afa, Corse", 
      lat: 41.9561, lng: 8.8025, radius: 700, length: 0.900, type: "karting" },
    { name: "Karting Bastia", location: "Borgo, Corse", 
      lat: 42.5614, lng: 9.4264, radius: 700, length: 0.950, type: "karting" },
    
    // ==========================================
    // CIRCUITS MOTO (28)
    // ==========================================
    
    { name: "Carole Moto", location: "Aulnay-sous-Bois, Île-de-France", 
      lat: 48.9534, lng: 2.4847, radius: 2000, length: 1.814, type: "moto" },
    { name: "Magny-Cours Moto", location: "Nevers, Bourgogne-Franche-Comté", 
      lat: 46.8642, lng: 3.1633, radius: 3000, length: 4.411, type: "moto" },
    { name: "Paul Ricard Moto", location: "Le Castellet, PACA", 
      lat: 43.2506, lng: 5.7919, radius: 3000, length: 5.842, type: "moto" },
    { name: "Dijon-Prenois Moto", location: "Prenois, Bourgogne-Franche-Comté", 
      lat: 47.3628, lng: 4.8997, radius: 2500, length: 3.801, type: "moto" },
    { name: "Lédenon Moto", location: "Lédenon, Occitanie", 
      lat: 43.9211, lng: 4.5025, radius: 2000, length: 3.156, type: "moto" },
    { name: "Alès Cévennes Moto", location: "Alès, Occitanie", 
      lat: 44.0678, lng: 4.0839, radius: 2000, length: 2.485, type: "moto" },
    { name: "Pau-Arnos Moto", location: "Arnos, Nouvelle-Aquitaine", 
      lat: 43.4556, lng: -0.4489, radius: 2500, length: 3.030, type: "moto" },
    { name: "Nogaro Moto", location: "Nogaro, Occitanie", 
      lat: 43.7611, lng: -0.0314, radius: 2500, length: 3.636, type: "moto" },
    { name: "Le Mans Moto", location: "Le Mans, Pays de la Loire", 
      lat: 47.9561, lng: 0.2269, radius: 3000, length: 4.185, type: "moto" },
    { name: "Lurcy-Lévis Moto", location: "Lurcy-Lévis, Auvergne-Rhône-Alpes", 
      lat: 46.7386, lng: 2.9286, radius: 2500, length: 3.750, type: "moto" },
    { name: "Issoire Moto", location: "Issoire, Auvergne-Rhône-Alpes", 
      lat: 45.5439, lng: 3.2769, radius: 2000, length: 3.100, type: "moto" },
    { name: "Anneau du Rhin Moto", location: "Biltzheim, Grand Est", 
      lat: 47.9536, lng: 7.3597, radius: 2500, length: 3.705, type: "moto" },
    { name: "Croix-en-Ternois Moto", location: "Croix-en-Ternois, Hauts-de-France", 
      lat: 50.3456, lng: 2.2347, radius: 2000, length: 2.500, type: "moto" },
    { name: "Clastres Moto", location: "Clastres, Hauts-de-France", 
      lat: 49.7414, lng: 3.2086, radius: 2000, length: 2.780, type: "moto" },
    { name: "Folembray Moto", location: "Folembray, Hauts-de-France", 
      lat: 49.6692, lng: 3.4647, radius: 1500, length: 2.080, type: "moto" },
    { name: "Val de Vienne Moto", location: "Le Vigeant, Nouvelle-Aquitaine", 
      lat: 46.5733, lng: 0.6578, radius: 2500, length: 3.775, type: "moto" },
    { name: "Bordeaux-Mérignac Moto", location: "Mérignac, Nouvelle-Aquitaine", 
      lat: 44.8311, lng: -0.6889, radius: 2000, length: 2.529, type: "moto" },
    { name: "Albi Moto", location: "Albi, Occitanie", 
      lat: 43.9147, lng: 2.1153, radius: 2000, length: 3.565, type: "moto" },
    { name: "La Ferté-Gaucher Moto", location: "La Ferté-Gaucher, Île-de-France", 
      lat: 48.7808, lng: 3.3072, radius: 2000, length: 2.800, type: "moto" },
    { name: "Bresse Moto", location: "Saint-Marcel, Bourgogne-Franche-Comté", 
      lat: 46.5261, lng: 5.3603, radius: 2000, length: 3.100, type: "moto" },
    { name: "Circuit du Var Moto", location: "Le Luc, PACA", 
      lat: 43.3847, lng: 6.3881, radius: 2000, length: 3.800, type: "moto" },
    { name: "Chambley Moto", location: "Chambley, Grand Est", 
      lat: 49.0225, lng: 5.8803, radius: 2500, length: 3.750, type: "moto" },
    { name: "Abbeville Moto", location: "Abbeville, Hauts-de-France", 
      lat: 50.0981, lng: 1.8392, radius: 1500, length: 1.720, type: "moto" },
    { name: "Dreux Moto", location: "Dreux, Centre-Val de Loire", 
      lat: 48.7531, lng: 1.3547, radius: 1500, length: 2.200, type: "moto" },
    { name: "Montlhéry Moto", location: "Linas, Île-de-France", 
      lat: 48.6428, lng: 2.2669, radius: 3000, length: 2.548, type: "moto" },
    { name: "Châteauroux Moto", location: "Châteauroux, Centre-Val de Loire", 
      lat: 46.8597, lng: 1.7253, radius: 2500, length: 3.650, type: "moto" },
    { name: "Faleyras Moto", location: "Faleyras, Nouvelle-Aquitaine", 
      lat: 44.7461, lng: -0.2578, radius: 1500, length: 1.900, type: "moto" },
    { name: "Mettet Moto", location: "Mettet, Belgique (proche France)", 
      lat: 50.3206, lng: 4.6617, radius: 2500, length: 2.650, type: "moto" },
];

let detectedCircuit = null;




function detectCircuitFromGPS() {
    if (!sessionData || !sessionData.gpsTrack || sessionData.gpsTrack.length === 0) {
        return null;
    }
    
    // Calculer le centre du tracé GPS
    const track = sessionData.gpsTrack;
    const centerLat = track.reduce((sum, p) => sum + p.lat, 0) / track.length;
    const centerLng = track.reduce((sum, p) => sum + p.lng, 0) / track.length;
    
    console.log(`Centre GPS: ${centerLat.toFixed(6)}, ${centerLng.toFixed(6)}`);
    
    // Chercher dans tous les circuits (base + custom)
    // Chercher uniquement dans la base de données
const allCircuits = CIRCUITS_DATABASE;
    
    for (const circuit of allCircuits) {
        const distance = calculateDistance(
            { lat: centerLat, lng: centerLng },
            { lat: circuit.lat, lng: circuit.lng }
        );
        
        console.log(`Distance ${circuit.name}: ${distance.toFixed(0)}m (rayon: ${circuit.radius}m)`);
        
        if (distance < circuit.radius) {
            console.log(`✓ Circuit détecté: ${circuit.name}`);
            return circuit;
        }
    }
    
    console.log('Aucun circuit reconnu');
    return null;
}

function showCircuitDetection() {
    detectedCircuit = detectCircuitFromGPS();
    
    const circuitInfo = document.getElementById('circuit-info');
    const circuitUnknown = document.getElementById('circuit-unknown');
    
    if (detectedCircuit) {
        circuitInfo.style.display = 'flex';
        circuitUnknown.style.display = 'none';
        
        document.querySelector('#circuit-info .circuit-icon').textContent = 
            detectedCircuit.type === 'auto' ? '🏎️' : '🏁';
        document.getElementById('circuit-name').textContent = detectedCircuit.name;
        document.getElementById('circuit-location').textContent = 
            `${detectedCircuit.location} - ${detectedCircuit.length} km`;
    } else {
        circuitInfo.style.display = 'none';
         circuitUnknown.style.display = 'block'; 
    }
}





console.log(`Base de données chargée: ${CIRCUITS_DATABASE.length} circuits`);
console.log(`- Auto: ${CIRCUITS_DATABASE.filter(c => c.type === 'auto').length}`);
console.log(`- Karting: ${CIRCUITS_DATABASE.filter(c => c.type === 'karting').length}`);
console.log(`- Moto: ${CIRCUITS_DATABASE.filter(c => c.type === 'moto').length}`);


// ==========================================
// GESTION DES PAGES
// ==========================================

function showLocalFileMode() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('upload-area').style.display = 'block';
    updateThemeButtonVisibility(false);
}

function showESP32Mode() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('esp32-page').style.display = 'block';
    updateThemeButtonVisibility(false);
}

function showStoredFiles() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('stored-files-page').style.display = 'block';
    loadStoredFilesList();
    updateThemeButtonVisibility(false);
}
// Fonction utilitaire pour gérer le bouton
// Fonction utilitaire pour gérer le toggle
function updateThemeButtonVisibility(showOnHomePage) {
    const themeContainer = document.querySelector('.theme-toggle-container');
    if (themeContainer) {
        themeContainer.style.display = showOnHomePage ? 'flex' : 'none';
    }
}
function returnToHome() {
    // Cacher toutes les pages
    document.getElementById('upload-area').style.display = 'none';
    document.getElementById('esp32-page').style.display = 'none';
    document.getElementById('stored-files-page').style.display = 'none';
    document.getElementById('settings-page').style.display = 'none';
    document.getElementById('session-content').style.display = 'none';

    // Déconnecter Bluetooth paramètres si connecté
    if (settingsBluetoothDevice && settingsBluetoothDevice.gatt.connected) {
        settingsBluetoothDevice.gatt.disconnect();
    }
    settingsBluetoothDevice = null;
    settingsBluetoothCharacteristic = null;
    
    // Réinitialiser
    if (map) {
        map.remove();
        map = null;
    }
    sessionData = null;
    currentSessionId = null;
    
    // Retour à l'accueil
    document.getElementById('home-page').style.display = 'block';
    updateStoredFilesCount();

    updateThemeButtonVisibility(true);
}

function returnToFileSelection() {
    document.getElementById('session-content').style.display = 'none';
    if (map) {
        map.remove();
        map = null;
    }
    
    // Retourner à la page d'origine
    if (currentSessionId && currentSessionId.startsWith('stored_')) {
        showStoredFiles();
    } else {
        showLocalFileMode();
    }
}

// ==========================================
// STOCKAGE LOCAL
// ==========================================

function saveSessionToStorage(data) {
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    const sessionId = 'stored_' + Date.now();
    
    // Utiliser l'ID de la session (format: "ddmmyyyy-hhmm")
    let filename = `session_${Date.now()}.json`; // Valeur par défaut
    
    if (data.id) {
        // L'ID est au format "09102025-1436"
        filename = `session_${data.id}.json`;
    }
    
    sessions.push({
        id: sessionId,
        data: data,
        savedAt: Date.now(),
        name: filename
    });
    
    localStorage.setItem('gpsSessions', JSON.stringify(sessions));
    updateStoredFilesCount();
    return sessionId;
}

function loadStoredFilesList() {
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    sessions.sort((a, b) => b.savedAt - a.savedAt);
    const container = document.getElementById('stored-files-list');
    
    if (sessions.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Aucune session sauvegardée</p>';
        return;
    }
    

    container.innerHTML = sessions.map((session, index) => {
        const date = new Date(session.savedAt);
        const data = session.data;
        
        return `
            <div class="file-item" id="file-item-${index}">
                <div class="file-item-checkbox">
                    <input type="checkbox" id="checkbox-${index}" onchange="updateSelectedCount()">
                </div>
                <div class="file-item-content">
                        <div class="file-item-header">
                        <div class="file-item-title">${session.name}</div>
                        <div class="file-item-date">${(data.data ? (data.data.size / 1024).toFixed(1) + ' Ko' : 'N/A')}</div>
                    </div>
                    <div class="file-item-stats">
                        <span>🏁 ${data.laps} tours</span>
                        <span>⏱️ Meilleur: ${formatTime(data.best)}</span>
                        <span>🚀 ${data.maxSpd.toFixed(1)} km/h</span>
                    </div>
                    <div class="file-item-actions">
                        <button class="file-action-btn btn-load" onclick="loadStoredSession(${index})">
                            📊 Analyser
                        </button>
                        <button class="file-action-btn btn-delete" onclick="deleteStoredSession(${index})">
                            🗑️ Supprimer
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    updateSelectedCount();
}

function loadStoredSession(index) {
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    if (sessions[index]) {
        currentSessionId = sessions[index].id;
        sessionData = sessions[index].data;
        document.getElementById('stored-files-page').style.display = 'none';
        displaySession();
    }
}

function deleteStoredSession(index) {
    if (!confirm('Supprimer cette session ?')) return;
    
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    sessions.splice(index, 1);
    localStorage.setItem('gpsSessions', JSON.stringify(sessions));
    loadStoredFilesList();
    updateStoredFilesCount();
}

function clearAllSessions() {
    if (!confirm('Supprimer TOUTES les sessions sauvegardées ? Cette action est irréversible.')) return;
    
    localStorage.removeItem('gpsSessions');
    loadStoredFilesList();
    updateStoredFilesCount();
}

// Afficher la page paramètres
function showSettingsPage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('settings-page').style.display = 'block';
    updateThemeButtonVisibility(false);
}

// Connexion Bluetooth pour les paramètres
async function connectForSettings() {
    const status = document.getElementById('settings-status');
    const connectBtn = document.getElementById('settings-connect-btn');
    
    status.style.display = 'block';
    status.style.background = '#fff3cd';
    status.style.color = '#856404';
    status.innerHTML = '🔄 Connexion Bluetooth...';
    connectBtn.disabled = true;
    
    try {
        // Connexion Bluetooth
        settingsBluetoothDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: 'GPS_Chrono' }],
            optionalServices: [SERVICE_UUID]
        });
        
        status.innerHTML = '🔄 Connexion au service BLE...';
        
        const server = await settingsBluetoothDevice.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        settingsBluetoothCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
        
        // Activer les notifications
        await settingsBluetoothCharacteristic.startNotifications();
        
        status.style.background = '#d4edda';
        status.style.color = '#155724';
        status.innerHTML = `✅ Connecté à ${settingsBluetoothDevice.name}`;
        
        // Charger la configuration actuelle
        await loadCurrentSettings();
        
        // Afficher le formulaire
        document.getElementById('settings-form').style.display = 'block';
        connectBtn.style.display = 'none';
        
    } catch (error) {
        status.style.background = '#f8d7da';
        status.style.color = '#721c24';
        status.innerHTML = `❌ Erreur: ${error.message}`;
        connectBtn.disabled = false;
    }
}

// Charger la configuration actuelle
async function loadCurrentSettings() {
    if (!settingsBluetoothCharacteristic) return;
    
    const status = document.getElementById('settings-status');
    status.style.background = '#fff3cd';
    status.innerHTML = '📥 Chargement de la configuration...';
    
    try {
        // Envoyer commande GET_CONFIG
        const encoder = new TextEncoder();
        await settingsBluetoothCharacteristic.writeValue(encoder.encode('GET_CONFIG\n'));
        
        // Attendre la réponse
        await new Promise((resolve) => {
            let responseBuffer = "";
            
            const handler = async (event) => {
                const value = event.target.value;
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(value);
                
                responseBuffer += text;
                
                // Vérifier si on a un JSON complet
                if (responseBuffer.includes('{') && responseBuffer.includes('}')) {
                    try {
                        const jsonStart = responseBuffer.indexOf('{');
                        const jsonEnd = responseBuffer.lastIndexOf('}') + 1;
                        const jsonStr = responseBuffer.substring(jsonStart, jsonEnd);
                        const response = JSON.parse(jsonStr);
                        
                        if (response.status === "OK" && response.config) {
                            currentConfig = response.config;
                            
                            // Remplir les champs
                            document.getElementById('param-lineHalfWidth').value = currentConfig.lineHalfWidth || 40;
                            document.getElementById('param-defineLineSpeed').value = currentConfig.defineLineSpeed || 40;
                            document.getElementById('param-ctrlSpeed').value = currentConfig.ctrlSpeed || 40;
                            document.getElementById('param-stopSpeed').value = currentConfig.stopSpeed || 5;
                            
                            status.style.background = '#d4edda';
                            status.style.color = '#155724';
                            status.innerHTML = '✅ Configuration chargée';
                            
                            settingsBluetoothCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                            resolve();
                        }
                    } catch (e) {
                        console.log('Parsing en cours...', e);
                    }
                }
            };
            
            settingsBluetoothCharacteristic.addEventListener('characteristicvaluechanged', handler);
            
            // Timeout après 5 secondes
            setTimeout(() => {
                settingsBluetoothCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                
                // Si pas de réponse, utiliser valeurs par défaut
                if (Object.keys(currentConfig).length === 0) {
                    document.getElementById('param-lineHalfWidth').value = 40;
                    document.getElementById('param-defineLineSpeed').value = 40;
                    document.getElementById('param-ctrlSpeed').value = 40;
                    document.getElementById('param-stopSpeed').value = 5;
                    
                    status.style.background = '#fff3cd';
                    status.innerHTML = '⚠️ Timeout - Valeurs par défaut chargées';
                }
                resolve();
            }, 5000);
        });
        
    } catch (error) {
        status.style.background = '#f8d7da';
        status.innerHTML = '❌ Erreur de chargement';
        console.error(error);
    }
}

// Sauvegarder les paramètres
async function saveSettings() {
    if (!settingsBluetoothCharacteristic) {
        alert('Non connecté au GPS LapTimer');
        return;
    }
    
    const status = document.getElementById('settings-status');
    status.style.background = '#fff3cd';
    status.innerHTML = '💾 Sauvegarde en cours...';
    
    try {
        // Récupérer les valeurs
        const config = {
            lineHalfWidth: parseFloat(document.getElementById('param-lineHalfWidth').value),
            defineLineSpeed: parseFloat(document.getElementById('param-defineLineSpeed').value),
            ctrlSpeed: parseFloat(document.getElementById('param-ctrlSpeed').value),
            stopSpeed: parseFloat(document.getElementById('param-stopSpeed').value)
        };
        
        // Envoyer commande SET_CONFIG
        const command = 'SET_CONFIG:' + JSON.stringify(config) + '\n';
        const encoder = new TextEncoder();
        await settingsBluetoothCharacteristic.writeValue(encoder.encode(command));
        
        // Attendre confirmation
        await new Promise((resolve) => setTimeout(resolve, 1000));
        
        status.style.background = '#d4edda';
        status.style.color = '#155724';
        status.innerHTML = '✅ Paramètres sauvegardés !';
        
        setTimeout(() => {
            status.innerHTML = '✅ Connecté - Paramètres à jour';
        }, 2000);
        
    } catch (error) {
        status.style.background = '#f8d7da';
        status.innerHTML = '❌ Erreur de sauvegarde';
        console.error(error);
    }
}

function updateStoredFilesCount() {
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    const countElement = document.getElementById('stored-count');
    if (countElement) {
        countElement.textContent = sessions.length === 0 ? 'Aucune session' : `${sessions.length} session(s) disponible(s)`;
    }
}

// ==========================================
// GESTION UPLOAD FICHIER LOCAL
// ==========================================

// Initialiser les event listeners pour l'upload
window.addEventListener('DOMContentLoaded', () => {
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    
    // Clic sur la zone d'upload
    uploadArea.addEventListener('click', (e) => {
        if (e.target.classList.contains('back-button')) return;
        fileInput.click();
    });
    
    // Sélection de fichier
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            readJSONFile(file);
        }
    });
    
    // Drag & Drop
    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('drag-over');
    });
    
    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('drag-over');
    });
    
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('drag-over');
        
        const file = e.dataTransfer.files[0];
        if (file && file.name.endsWith('.json')) {
            readJSONFile(file);
        } else {
            alert('Veuillez sélectionner un fichier JSON');
        }
    });
});

// Lire et traiter le fichier JSON
function readJSONFile(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
        try {
            const json = JSON.parse(e.target.result);
            
            // Vérifier que c'est bien un fichier de session GPS
            if (!json.laps || !json.times || !json.best) {
                alert('Fichier JSON invalide. Assurez-vous qu\'il s\'agit d\'une session GPS valide.');
                return;
            }
            
            sessionData = json;
            currentSessionId = 'local_' + Date.now();
            
            // Sauvegarder automatiquement
            saveSessionToStorage(json);
            
            // Afficher la session
            document.getElementById('upload-area').style.display = 'none';
            displaySession();
            
        } catch (error) {
            alert('Erreur de lecture du fichier JSON:\n' + error.message);
            console.error('Erreur:', error);
        }
    };
    
    reader.onerror = () => {
        alert('Erreur de lecture du fichier');
    };
    
    reader.readAsText(file);
}

function toggleSelectAll() {
    const checkboxes = document.querySelectorAll('[id^="checkbox-"]');
    const btn = document.getElementById('toggle-select-btn');
    
    // Vérifier si toutes sont cochées
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
    
    if (allChecked) {
        // Tout décocher
        checkboxes.forEach(cb => cb.checked = false);
        btn.innerHTML = '☑️ Tout sélectionner';
        btn.style.background = '#2196f3';
    } else {
        // Tout cocher
        checkboxes.forEach(cb => cb.checked = true);
        btn.innerHTML = '☐ Tout désélectionner';
        btn.style.background = '#9e9e9e';
    }
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const checkboxes = document.querySelectorAll('[id^="checkbox-"]');
    const checkedBoxes = document.querySelectorAll('[id^="checkbox-"]:checked');
    const count = checkedBoxes.length;
    const btn = document.getElementById('toggle-select-btn');
    const countSpan = document.getElementById('selected-count');
    const downloadBtn = document.getElementById('download-selected-btn');
    
    // Mettre à jour le bouton de sélection
    if (btn) {
        if (count === checkboxes.length && count > 0) {
            btn.innerHTML = '☐ Tout désélectionner';
            btn.style.background = '#9e9e9e';
        } else {
            btn.innerHTML = '☑️ Tout sélectionner';
            btn.style.background = '#2196f3';
        }
    }
    
    // Mettre à jour le bouton de téléchargement
    if (downloadBtn && countSpan) {
        if (count > 0) {
            downloadBtn.style.display = 'inline-block';
            countSpan.textContent = count;
        } else {
            downloadBtn.style.display = 'none';
        }
    }
    
    // Mettre en surbrillance les items sélectionnés
    document.querySelectorAll('.file-item').forEach((item, index) => {
        const checkbox = document.getElementById(`checkbox-${index}`);
        if (checkbox && checkbox.checked) {
            item.classList.add('selected');
        } else {
            item.classList.remove('selected');
        }
    });
}

async function downloadSelectedSessions() {
    const sessions = JSON.parse(localStorage.getItem('gpsSessions') || '[]');
    const checkboxes = document.querySelectorAll('[id^="checkbox-"]:checked');
    const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.id.replace('checkbox-', '')));
    
    if (selectedIndices.length === 0) {
        alert('Aucune session sélectionnée');
        return;
    }
    
    if (selectedIndices.length === 1) {
        // Télécharger un seul fichier JSON
        const session = sessions[selectedIndices[0]];
        const json = JSON.stringify(session.data, null, 2);
        const filename = `session_${session.data.id || 'export'}.json`;
        downloadFile(json, filename, 'application/json');
    } else {
        // Télécharger plusieurs fichiers en ZIP
        await downloadMultipleSessionsAsZip(sessions, selectedIndices);
    }
}

async function downloadMultipleSessionsAsZip(sessions, selectedIndices) {
    if (typeof JSZip === 'undefined') {
        alert('Bibliothèque ZIP non chargée. Téléchargement des fichiers individuellement...');
        selectedIndices.forEach(index => {
            const session = sessions[index];
            const json = JSON.stringify(session.data, null, 2);
            const filename = `session_${session.data.id || index}.json`;
            downloadFile(json, filename, 'application/json');
        });
        return;
    }
    
    const zip = new JSZip();
    const folder = zip.folder('gps_sessions');
    
    selectedIndices.forEach(index => {
        const session = sessions[index];
        const json = JSON.stringify(session.data, null, 2);
        const filename = `session_${session.data.id || index}.json`;
        folder.file(filename, json);
    });
    
    try {
        const content = await zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 9 }
        });
        
        const timestamp = new Date().toISOString().split('T')[0];
        downloadFile(content, `gps_sessions_${timestamp}.zip`, 'application/zip');
    } catch (error) {
        alert('Erreur lors de la création du ZIP: ' + error.message);
    }
}

// ==========================================
// CONNEXION ESP32
// ==========================================




// Initialisation au chargement
window.addEventListener('DOMContentLoaded', () => {
    updateStoredFilesCount();
});
        // ==========================================
// CONNEXION ESP32 / GPS_LAPTIMER
// ==========================================

// ==========================================
// CONNEXION ESP32 / GPS_LAPTIMER - BLUETOOTH BLE
// ==========================================

async function connectESP32() {
    const status = document.getElementById('esp32-status');
    
    status.style.display = 'block';
    status.style.background = '#fff3cd';
    status.style.color = '#856404';
    status.innerHTML = '🔄 Connexion Bluetooth...';
    
    try {
        // Demander connexion Bluetooth
        bluetoothDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: 'GPS_Chrono' }],
            optionalServices: [SERVICE_UUID]
        });
        
        status.innerHTML = '🔄 Connexion au service BLE...';
        
        const server = await bluetoothDevice.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        bluetoothCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
        
        // Activer les notifications
        await bluetoothCharacteristic.startNotifications();
        bluetoothCharacteristic.addEventListener('characteristicvaluechanged', handleBLENotification);
        
        // Gérer la déconnexion
        bluetoothDevice.addEventListener('gattserverdisconnected', onBLEDisconnected);
        
        status.style.background = '#d4edda';
        status.style.color = '#155724';
        status.innerHTML = `✅ Connecté à ${bluetoothDevice.name}`;
        
        // Récupérer la liste des fichiers
        await sendBLECommand('LIST');
        
    } catch (error) {
        status.style.background = '#f8d7da';
        status.style.color = '#721c24';
        status.innerHTML = `❌ Erreur: ${error.message}<br><small>Vérifiez:<br>
            1. Bluetooth activé<br>
            2. GPS_LapTimer allumé<br>
            3. Navigateur compatible (Chrome/Edge)</small>`;
    }
}

function onBLEDisconnected() {
    console.log('Bluetooth déconnecté');
    bluetoothDevice = null;
    bluetoothCharacteristic = null;
    alert('Connexion Bluetooth perdue');
}

// ==========================================
// GESTION RÉCEPTION DONNÉES BLUETOOTH
// ==========================================

function handleBLENotification(event) {
    const value = event.target.value;
    const decoder = new TextDecoder('utf-8');
    const text = decoder.decode(value);
    
    // Debug uniquement pour les petits messages
    if (text.length < 100) {
        console.log('BLE reçu:', text);
    }
    
    // Si on reçoit un fichier complet
    if (isReceivingFile) {
        // Détecter EOF (peut être avec ou sans \n, seul ou avec des données)
        if (text.trim() === "EOF" || text === "EOF\n") {
            // Fin de fichier
            console.log(`✅ Fichier complet reçu: ${receivedFileData.length} octets`);
            isReceivingFile = false;
            
            // Attendre un peu pour s'assurer que tout est bien reçu
            setTimeout(() => {
                processBLEFileData(receivedFileData);
                receivedFileData = "";
                expectedFileSize = 0;
            }, 100);
            
        } else if (text.startsWith("SIZE:")) {
            // Taille du fichier annoncée
            expectedFileSize = parseInt(text.substring(5).trim());
            console.log(`📦 Fichier attendu: ${expectedFileSize} octets`);
            receivedFileData = ""; // Réinitialiser
            
        } else {
            // Données du fichier (ne pas inclure EOF s'il est dans le même chunk)
            let cleanText = text.replace(/EOF\n?$/, ''); // Supprimer EOF en fin seulement
            receivedFileData += cleanText;
            
            // Afficher progression tous les 5000 octets
            if (receivedFileData.length % 5000 < 200) {
                const progress = expectedFileSize > 0 
                    ? ((receivedFileData.length / expectedFileSize) * 100).toFixed(0)
                    : '?';
                console.log(`📥 Réception: ${receivedFileData.length} octets (${progress}%)`);
                
                const status = document.getElementById('esp32-status');
                if (status) {
                    status.innerHTML = `📥 Téléchargement: ${receivedFileData.length} / ${expectedFileSize} octets (${progress}%)`;
                }
            }
        }
    } else {
        // Réponse normale (JSON court)
        bleDataBuffer += text;
        
        // Traiter quand on a une ligne complète
        if (text.includes('\n') || text.includes('EOF')) {
            processBLEResponse(bleDataBuffer);
            bleDataBuffer = "";
        }
    }
}

// ==========================================
// ENVOI COMMANDES ET TRAITEMENT RÉPONSES
// ==========================================

async function sendBLECommand(command) {
    if (!bluetoothCharacteristic) {
        alert('Bluetooth non connecté');
        return;
    }
    
    console.log('Envoi commande BLE:', command);
    const encoder = new TextEncoder();
    const data = encoder.encode(command + '\n');
    await bluetoothCharacteristic.writeValue(data);
}

function processBLEResponse(data) {
    try {
        // Nettoyer les données (EOF peut être dans les chunks)
        data = data.replace(/EOF\n?/g, '').trim();
        
        console.log('Traitement réponse BLE:', data.substring(0, 100));
        
        // Parser le JSON principal
        const json = JSON.parse(data);
        
        console.log('JSON parsé:', json);
        
        if (json.status === "OK") {
            // Cas 1 : data est déjà un objet
            if (json.data && typeof json.data === 'object') {
                if (json.data.files) {
                    console.log(`${json.data.files.length} fichiers trouvés`);
                    displayESP32Files(json.data.files, 'BLE');
                }
            }
            // Cas 2 : data est une string JSON
            else if (json.data && typeof json.data === 'string') {
                const parsedData = JSON.parse(json.data);
                if (parsedData.files) {
                    console.log(`${parsedData.files.length} fichiers trouvés`);
                    displayESP32Files(parsedData.files, 'BLE');
                }
            }
        } 
        // Cas 3 : Réponse directe sans wrapper
        else if (json.files) {
            console.log(`${json.files.length} fichiers trouvés (format direct)`);
            displayESP32Files(json.files, 'BLE');
        }
        else if (json.status === "ERROR") {
            alert('Erreur ESP32: ' + json.message);
        }
    } catch (error) {
        console.error('Erreur parsing JSON:', error);
        console.log('Données brutes complètes:', data);
    }
}

function processBLEFileData(data) {
    try {
        // Nettoyer agressivement
        data = data.replace(/EOF\n?/g, '').trim();
        
        console.log('📄 Parsing JSON...');
        console.log('Premiers caractères:', data.substring(0, 100));
        console.log('Derniers caractères:', data.substring(data.length - 100));
        
        // Vérifier que ça commence et finit bien par { }
        if (!data.startsWith('{') || !data.endsWith('}')) {
            console.error('❌ JSON malformé - début ou fin incorrect');
            throw new Error('Format JSON invalide');
        }
        
        const json = JSON.parse(data);
        
        console.log('✅ JSON parsé avec succès');
        console.log('Session:', json.id, '/', json.laps, 'tours /', json.points, 'points GPS');
        
        sessionData = json;
        currentSessionId = 'ble_' + json.id;
        
        // Sauvegarder automatiquement
        saveSessionToStorage(json);
        
        document.getElementById('esp32-page').style.display = 'none';
        document.getElementById('esp32-status').style.display = 'none';
        displaySession();
        
    } catch (error) {
        console.error('❌ Erreur lecture fichier:', error);
        console.log('Taille données reçues:', data.length);
        console.log('Position erreur:', error.message);
        
        // Essayer de sauvegarder les données brutes pour debug
        console.log('Données complètes:', data);
        
        alert('Erreur lecture fichier JSON\nVoir console (F12) pour détails');
        
        const status = document.getElementById('esp32-status');
        status.style.background = '#f8d7da';
        status.style.color = '#721c24';
        status.innerHTML = '❌ Fichier JSON invalide<br><small>Ouvrir Console (F12) pour détails</small>';
        
        isReceivingFile = false;
    }
}

function displayESP32Files(sessions, source) {
    const container = document.getElementById('esp32-files-container');
    const listDiv = document.getElementById('esp32-files-list');
    
    listDiv.style.display = 'block';
    
    if (!sessions || sessions.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #999;">Aucune session trouvée</p>';
        return;
    }
    
    // INVERSER L'ORDRE : dernière session en premier
    const reversedSessions = [...sessions].reverse();
    
    const sessionsHTML = reversedSessions.map((session, index) => {
        const filename = session.name;
        const fileSize = session.size ? `${(session.size / 1024).toFixed(1)} Ko` : 'N/A';
        
        return `
            <div class="file-item" id="esp32-file-item-${index}">
                <div class="file-item-content">
                    <div class="file-item-header">
                        <div class="file-item-title">${filename}</div>
                        <div class="file-item-date">${fileSize}</div>
                    </div>
                    <div class="file-item-actions">
                        <button class="file-action-btn btn-load" onclick="loadESP32File('${filename}')">
                            📊 Analyser
                        </button>
                        <button class="file-action-btn btn-load" onclick="downloadESP32File('${filename}')" style="background: #2196f3;">
                            📥 Télécharger
                        </button>
                        <button class="file-action-btn btn-delete" onclick="deleteESP32File('${filename}')">
                            🗑️ Supprimer
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = '<div style="max-width: 800px; margin: 0 auto;">' + sessionsHTML + '</div>';
}



async function loadESP32File(filename) {
    try {
        isReceivingFile = true;
        receivedFileData = "";
        
        const status = document.getElementById('esp32-status');
        status.style.display = 'block';
        status.style.background = '#fff3cd';
        status.style.color = '#856404';
        status.innerHTML = '📥 Téléchargement en cours...';
        
        console.log('Demande fichier:', filename);
        await sendBLECommand('GET:' + filename);
        
    } catch (error) {
        console.error('Erreur téléchargement:', error);
        alert('Erreur de téléchargement: ' + error.message);
        isReceivingFile = false;
        
        const status = document.getElementById('esp32-status');
        status.style.background = '#f8d7da';
        status.innerHTML = '❌ Échec du téléchargement';
    }
}
        
async function downloadESP32File(filename) {
    try {
        isReceivingFile = true;
        receivedFileData = "";
        
        const status = document.getElementById('esp32-status');
        status.style.display = 'block';
        status.style.background = '#fff3cd';
        status.style.color = '#856404';
        status.innerHTML = '📥 Téléchargement pour sauvegarde...';
        
        console.log('Téléchargement fichier:', filename);
        await sendBLECommand('GET:' + filename);
        
        // Attendre la fin du téléchargement
        const checkInterval = setInterval(() => {
            if (!isReceivingFile && receivedFileData.length > 0) {
                clearInterval(checkInterval);
                
                // Télécharger le fichier
                const blob = new Blob([receivedFileData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                status.innerHTML = '✅ Fichier téléchargé';
                
                setTimeout(() => {
                    status.style.display = 'none';
                }, 2000);
            }
        }, 500);
        
    } catch (error) {
        console.error('Erreur téléchargement:', error);
        alert('Erreur de téléchargement: ' + error.message);
        
        const status = document.getElementById('esp32-status');
        status.style.background = '#f8d7da';
        status.innerHTML = '❌ Échec du téléchargement';
    }
}

async function deleteESP32File(filename) {
    if (!confirm(`Supprimer le fichier "${filename}" du GPS_LapTimer ?`)) {
        return;
    }
    
    try {
        const status = document.getElementById('esp32-status');
        status.style.display = 'block';
        status.style.background = '#fff3cd';
        status.style.color = '#856404';
        status.innerHTML = '🗑️ Suppression en cours...';
        
        console.log('Suppression fichier:', filename);
        await sendBLECommand('DELETE:' + filename);
        
        // Attendre confirmation
        setTimeout(async () => {
            status.style.background = '#d4edda';
            status.style.color = '#155724';
            status.innerHTML = '✅ Fichier supprimé';
            
            // Rafraîchir la liste
            await sendBLECommand('LIST');
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 2000);
        }, 1000);
        
    } catch (error) {
        console.error('Erreur suppression:', error);
        alert('Erreur de suppression: ' + error.message);
        
        const status = document.getElementById('esp32-status');
        status.style.background = '#f8d7da';
        status.innerHTML = '❌ Échec de la suppression';
    }
}

        function displaySession() {
        document.getElementById('upload-area').style.display = 'none';
        document.getElementById('session-content').style.display = 'block';
        updateThemeButtonVisibility(false);

     if (!document.querySelector('#session-back-button')) {
        const backBtn = document.createElement('button');
        backBtn.id = 'session-back-button';
        backBtn.className = 'back-button';
        backBtn.textContent = '← Changer de fichier';
        backBtn.onclick = returnToFileSelection;
        document.getElementById('session-content').insertBefore(
            backBtn, 
            document.getElementById('session-content').firstChild
        );
    }
    
    function recalculateMaxSpeed() {
    if (!sessionData || !sessionData.gpsTrack || sessionData.gpsTrack.length === 0) {
        return sessionData.maxSpd || 0;
    }
    
    const speeds = sessionData.gpsTrack.map(p => p.spd);
    return Math.max(...speeds);
}
    
    document.getElementById('session-title').textContent = 'Session Circuit - Analyse GPS';
    
    // === CORRECTION DATE : Extraire depuis l'ID ===
    let dateText = "Date inconnue";
    
    if (sessionData.id) {
        // Format ID: "01102025-1430" ou "ddmmyyyy-hhmm"
        const parts = sessionData.id.split('-');
        if (parts.length === 2) {
            const dateStr = parts[0]; // "01102025"
            const timeStr = parts[1]; // "1430"
            
            const day = dateStr.substring(0, 2);
            const month = dateStr.substring(2, 4);
            const year = dateStr.substring(4, 8);
            const hour = timeStr.substring(0, 2);
            const minute = timeStr.substring(2, 4);
            
            // Créer un texte lisible
            dateText = `${day}/${month}/${year} à ${hour}:${minute}`;
        } else {
            dateText = sessionData.id; // Afficher l'ID brut si format inconnu
        }
    }
    
    document.getElementById('session-date').textContent = dateText;
            
            const trackLength = sessionData.trackLength || 1.814;
            document.getElementById('session-badge').textContent = `${trackLength} km - ${sessionData.laps} tours`;
            
            document.getElementById('stat-laps').textContent = sessionData.laps;
            document.getElementById('stat-best').textContent = formatTime(sessionData.best);
            const realMaxSpeed = recalculateMaxSpeed();
            document.getElementById('stat-maxspeed').textContent = realMaxSpeed.toFixed(1);
            
            const avgSpeed = calculateAverageSpeed();
            document.getElementById('stat-avgspeed').textContent = avgSpeed.toFixed(1);
            document.getElementById('stat-distance').textContent = trackLength.toFixed(3);
            
            const totalTime = sessionData.times.reduce((a, b) => a + b, 0);
            document.getElementById('stat-total').textContent = formatTime(totalTime);

           
            
            segmentLapsFromGPSTrack();
            displayLapsTable();
            displayAnalysis();
            displayProgression();
                     

        }

        function showAllCircuits() {
    const modal = document.createElement('div');
    modal.id = 'circuits-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 10000;
        display: flex; align-items: center; justify-content: center;
        padding: 20px; overflow-y: auto;
    `;
    
    let html = `
        <div class="modal-content-circuits" style="border-radius: 15px; padding: 30px; max-width: 600px; 
                    width: 100%; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 class="modal-title-circuits" style="margin: 0;">🏁 Sélection du Circuit</h3>
                <button onclick="document.getElementById('circuits-modal').remove()" 
                        style="background: #f44336; color: white; border: none; padding: 8px 15px; 
                               border-radius: 5px; cursor: pointer;">✕</button>
            </div>
            <p class="modal-desc-circuits" style="margin-bottom: 20px;">Circuit non détecté automatiquement. Veuillez sélectionner :</p>
    `;
    
    // Circuits automobile
    html += `<h3 class="modal-section-title-auto" style="padding-bottom: 5px; margin: 20px 0 15px 0; border-bottom: 2px solid;">
             🏎️ Circuits Automobile</h3>`;
    
    CIRCUITS_DATABASE.filter(c => c.type === 'auto').forEach(circuit => {
        html += `
            <div class="modal-circuit-item" onclick="selectCircuitManually('${circuit.name}')" 
                 style="border-radius: 8px; padding: 12px; margin-bottom: 5px; cursor: pointer; transition: all 0.2s; border: 1px solid;">
                <strong>${circuit.name}</strong><br>
                <small class="modal-circuit-location">${circuit.location} - ${circuit.length} km</small>
            </div>
        `;
    });
    
    // Circuits karting
    html += `<h3 style="color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 5px; margin: 25px 0 15px 0;">
             🏁 Circuits Karting</h3>`;
    
    CIRCUITS_DATABASE.filter(c => c.type === 'karting').forEach(circuit => {
        html += `
            <div class="modal-circuit-item modal-circuit-karting" onclick="selectCircuitManually('${circuit.name}')" 
                 style="border-radius: 8px; padding: 12px; margin-bottom: 5px; cursor: pointer; transition: all 0.2s; border: 1px solid #ff9800;">
                <strong>${circuit.name}</strong><br>
                <small class="modal-circuit-location">${circuit.location} - ${circuit.length} km</small>
            </div>
        `;
    });
    
    html += '</div>';
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    // APPLIQUER LES COULEURS APRÈS CRÉATION
    applyModalTheme();
}

// Nouvelle fonction pour appliquer le thème
function applyModalTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    
    console.log('🎨 applyModalTheme appelée, isDark =', isDark); // DEBUG
    
    if (isDark) {
        const content = document.querySelector('.modal-content-circuits');
        if (content) {
            content.style.setProperty('background', '#252525', 'important');
            content.style.setProperty('color', '#e0e0e0', 'important');
            console.log('✅ Styles sombres appliqués au conteneur'); // DEBUG
        }
        
        const title = document.querySelector('.modal-title-circuits');
        if (title) title.style.setProperty('color', '#64b5f6', 'important');
        
        const desc = document.querySelector('.modal-desc-circuits');
        if (desc) desc.style.setProperty('color', '#b0b0b0', 'important');
        
        const sectionTitle = document.querySelector('.modal-section-title-auto');
        if (sectionTitle) {
            sectionTitle.style.setProperty('color', '#64b5f6', 'important');
            sectionTitle.style.setProperty('border-bottom-color', '#64b5f6', 'important');
        }
        
        document.querySelectorAll('.modal-circuit-item').forEach(item => {
            item.style.setProperty('background', '#252525', 'important');
            item.style.setProperty('color', '#e0e0e0', 'important');
            if (!item.classList.contains('modal-circuit-karting')) {
                item.style.setProperty('border-color', '#404040', 'important');
            }
        });
        
        document.querySelectorAll('.modal-circuit-location').forEach(loc => {
            loc.style.setProperty('color', '#b0b0b0', 'important');
        });
        
    } else {
        // Mode clair
        const content = document.querySelector('.modal-content-circuits');
        if (content) {
            content.style.setProperty('background', '#ffffff', 'important');
            content.style.setProperty('color', '#333333', 'important');
        }
        
        const title = document.querySelector('.modal-title-circuits');
        if (title) title.style.setProperty('color', '#1976d2', 'important');
        
        const desc = document.querySelector('.modal-desc-circuits');
        if (desc) desc.style.setProperty('color', '#666666', 'important');
        
        const sectionTitle = document.querySelector('.modal-section-title-auto');
        if (sectionTitle) {
            sectionTitle.style.setProperty('color', '#1976d2', 'important');
            sectionTitle.style.setProperty('border-bottom-color', '#1976d2', 'important');
        }
        
        document.querySelectorAll('.modal-circuit-item').forEach(item => {
            item.style.setProperty('background', '#ffffff', 'important');
            item.style.setProperty('color', '#333333', 'important');
            if (!item.classList.contains('modal-circuit-karting')) {
                item.style.setProperty('border-color', '#e0e0e0', 'important');
            }
        });
        
        document.querySelectorAll('.modal-circuit-location').forEach(loc => {
            loc.style.setProperty('color', '#666666', 'important');
        });
    }
}
function applyPageTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    
    // Boîte comparaison
    const comparisonBox = document.querySelector('.comparison-controls');
    if (comparisonBox) {
        if (isDark) {
            comparisonBox.style.background = '#2d2d2d';
            comparisonBox.style.borderLeftColor = '#ff9800';
            
            const h4 = comparisonBox.querySelector('h4');
            if (h4) h4.style.color = '#ffb74d';
            
            const p = comparisonBox.querySelector('p');
            if (p) p.style.color = '#b0b0b0';
            
            comparisonBox.querySelectorAll('label').forEach(label => {
                label.style.color = '#e0e0e0';
            });
            
            comparisonBox.querySelectorAll('select').forEach(select => {
                select.style.background = '#252525';
                select.style.color = '#e0e0e0';
                select.style.borderColor = '#404040';
            });
        } else {
            comparisonBox.style.background = '#fff3e0';
            comparisonBox.style.borderLeftColor = '#ff9800';
            
            const h4 = comparisonBox.querySelector('h4');
            if (h4) h4.style.color = '#ff6f00';
            
            const p = comparisonBox.querySelector('p');
            if (p) p.style.color = '#666';
            
            comparisonBox.querySelectorAll('label').forEach(label => {
                label.style.color = '#333';
            });
            
            comparisonBox.querySelectorAll('select').forEach(select => {
                select.style.background = '#fff';
                select.style.color = '#333';
                select.style.borderColor = '#ddd';
            });
        }
    }
    
    // Boîte circuit non identifié
    const autoDetectBox = document.querySelector('.auto-detect-box');
    if (autoDetectBox) {
        if (isDark) {
            autoDetectBox.style.background = '#2d2d2d';
            autoDetectBox.style.borderLeftColor = '#64b5f6';
            
            const h4 = autoDetectBox.querySelector('h4');
            if (h4) h4.style.color = '#64b5f6';
            
            const p = autoDetectBox.querySelector('p');
            if (p) p.style.color = '#b0b0b0';
        } else {
            autoDetectBox.style.background = '#e3f2fd';
            autoDetectBox.style.borderLeftColor = '#1976d2';
            
            const h4 = autoDetectBox.querySelector('h4');
            if (h4) h4.style.color = '#1976d2';
            
            const p = autoDetectBox.querySelector('p');
            if (p) p.style.color = '#666';
        }
    }
}
function selectCircuitManually(circuitName) {
    // Chercher uniquement dans la base de données
const allCircuits = CIRCUITS_DATABASE;
    detectedCircuit = allCircuits.find(c => c.name === circuitName);
    
    document.getElementById('circuits-modal').remove();
    showCircuitDetection();
    
    console.log('Circuit sélectionné manuellement:', detectedCircuit.name);
}
        
        function displayLapsTable() {
    const tbody = document.querySelector('#laps-table tbody');
    tbody.innerHTML = '';
    
    const bestTime = sessionData.best;
    let bestLapIndex = sessionData.times.findIndex(t => t === bestTime);
    
    sessionData.times.forEach((time, index) => {
        const row = document.createElement('tr');
        if (index === bestLapIndex) row.classList.add('best-lap');
        
        const delta = time - bestTime;
        const deltaClass = delta === 0 ? 'delta-zero' : 'delta-positive';
        const deltaSign = delta === 0 ? '' : '+';
        
        // Calculer les vraies vitesses depuis les segments de tours
        let maxSpeed = 0;
        let avgSpeed = 0;
        
        if (lapSegments && lapSegments[index]) {
            const lapPoints = lapSegments[index].points;
            const speeds = lapPoints.map(p => p.spd);
            maxSpeed = Math.max(...speeds);
            avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        } else {
            // Fallback si pas de données GPS
            const trackLength = sessionData.trackLength || 1.814;
            avgSpeed = (trackLength / (time / 1000)) * 3600;
            maxSpeed = sessionData.maxSpd || 0;
        }
        
        row.innerHTML = `
            <td>${index + 1}</td>
            <td>${formatTime(time)}</td>
            <td class="${deltaClass}">${deltaSign}${(delta/1000).toFixed(3)}</td>
            <td>${maxSpeed.toFixed(1)}</td>
            <td>${avgSpeed.toFixed(1)}</td>
        `;
        tbody.appendChild(row);
    });
}
        
        function displayAnalysis() {
            const grid = document.getElementById('analysis-grid');
            const times = sessionData.times;
            
            const avg = times.reduce((a, b) => a + b, 0) / times.length;
            const variance = times.reduce((sum, time) => sum + Math.pow(time - avg, 2), 0) / times.length;
            const stdDev = Math.sqrt(variance);
            const consistency = Math.max(0, 100 - (stdDev / avg) * 100);
            
            grid.innerHTML = `
                <div class="analysis-card">
                    <h4>Consistance des Tours</h4>
                    <p><strong>Ecart-type:</strong> ${(stdDev/1000).toFixed(3)}s</p>
                    <p><strong>Consistance:</strong> ${consistency.toFixed(1)}%</p>
                    <div style="background: #e0e0e0; height: 20px; border-radius: 10px; margin: 10px 0; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #4caf50, #8bc34a); height: 100%; width: ${consistency}%; border-radius: 10px;"></div>
                    </div>
                </div>
                <div class="analysis-card">
                    <h4>Performance</h4>
                    <p><strong>Meilleur tour:</strong> ${formatTime(sessionData.best)}</p>
                    <p><strong>Vitesse max:</strong> ${sessionData.maxSpd.toFixed(1)} km/h</p>
                    <p><strong>Tours sub-1'08:</strong> ${times.filter(t => t < 68000).length}/${times.length}</p>
                </div>
                <div class="analysis-card">
                    <h4>Progression</h4>
                    <p><strong>Premier tour:</strong> ${formatTime(times[0])}</p>
                    <p><strong>Dernier tour:</strong> ${formatTime(times[times.length-1])}</p>
                    <p><strong>Amelioration:</strong> ${((times[0]-sessionData.best)/1000).toFixed(3)}s</p>
                </div>
                <div class="analysis-card">
                    <h4>Statistiques Globales</h4>
                    <p><strong>Temps moyen:</strong> ${formatTime(avg)}</p>
                    <p><strong>Tours total:</strong> ${times.length}</p>
                    <p><strong>Points GPS:</strong> ${sessionData.points || '-'}</p>
                </div>
            `;
        }
        
    function displayProgression() {
    const container = document.getElementById('progress-bars');
    const times = sessionData.times;
    const bestTime = sessionData.best;
    const worstTime = Math.max(...times);
    
    container.innerHTML = times.map((time, index) => {
        const delta = time - bestTime;
        const realPercentage = ((worstTime - time) / (worstTime - bestTime)) * 100;
        const displayPercentage = Math.max(realPercentage, 8);
        
        let color = '';
        if (time === bestTime) color = 'linear-gradient(90deg, #4caf50, #8bc34a)';
        else if (delta < 1000) color = 'linear-gradient(90deg, #2196f3, #64b5f6)';
        else if (delta < 2000) color = 'linear-gradient(90deg, #ff9800, #ffb74d)';
        else color = 'linear-gradient(90deg, #f44336, #ef5350)';
        
        const timeText = formatTime(time);
        const deltaText = delta === 0 ? '(RECORD)' : `(+${(delta/1000).toFixed(3)}s)`;
        const fullText = `${timeText} ${deltaText}`;
        
        const textLength = fullText.length;
        const textWidth = textLength * 7;
        const barWidth = (500 * displayPercentage) / 100;
        const textFitsInside = barWidth > (textWidth + 20);
        
        return `
            <div class="progress-item">
                <div class="progress-label">T${index + 1}</div>
                <div style="position: relative; flex: 1; display: flex; align-items: center;">
                    <div class="progress-bar-container" style="overflow: visible !important;">
                        <div class="progress-bar" style="width: ${displayPercentage}%; background: ${color}; display: flex; align-items: center; justify-content: center;">
                            ${textFitsInside ? `<span style="color: #ffffff !important; font-weight: bold; text-shadow: 0 1px 3px rgba(0,0,0,0.5); z-index: 1;">${fullText}</span>` : ''}
                        </div>
                    </div>
                    ${!textFitsInside ? `
                        <span style="color: #000000 !important; background: transparent !important; position: absolute; left: calc(${displayPercentage}% + 18px); font-size: 0.85rem; font-weight: bold; white-space: nowrap; z-index: 10;">${fullText}</span>
                    ` : ''}
                </div>
            </div>
        `;
    }).join('');
}
        
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            
            document.getElementById(`${tabName}-content`).classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'track' && sessionData && sessionData.gpsTrack) {
    setTimeout(() => {
        if (!map) {
            initMap(); // Initialise la carte ET affiche le tracé
        } else {
            map.invalidateSize();
        }
        showCircuitDetection();
        applyPageTheme(); // Détection circuit séparée (info bonus)
    }, 100);
}
            
            if (tabName === 'turns' && sessionData && sessionData.gpsTrack) analyzeTurns();
        }
        
        function initMap() {
            if (!sessionData || !sessionData.gpsTrack || sessionData.gpsTrack.length === 0) {
                document.getElementById('map').innerHTML = '<div style="padding: 50px; text-align: center; color: #999;">Aucune donnee GPS disponible</div>';
                return;
            }
            
            const track = sessionData.gpsTrack;
            const centerLat = track.reduce((sum, p) => sum + p.lat, 0) / track.length;
            const centerLng = track.reduce((sum, p) => sum + p.lng, 0) / track.length;
            
            map = L.map('map').setView([centerLat, centerLng], 15);
            addMapTiles();
            displayBestLap();
            
            setTimeout(() => map.invalidateSize(), 100);
        }
        
        function addMapTiles() {
            if (currentMapView === 'satellite') {
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles Esri',
                    maxZoom: 19
                }).addTo(map);
            } else {
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(map);
            }
        }
        
        function getAccelerationColor(prevSpeed, currentSpeed, nextSpeed) {
            const accel1 = currentSpeed - prevSpeed;
            const accel2 = nextSpeed - currentSpeed;
            const avgAccel = (accel1 + accel2) / 2;
            
            // Seuils ajustés pour GPS à haute fréquence
            if (avgAccel < -3) return '#ff0000';      // Rouge: forte décélération
            else if (avgAccel < -1) return '#ff8800';  // Orange: décélération moyenne
            else if (avgAccel < 1) return '#ffff00';   // Jaune: vitesse stable
            else if (avgAccel < 3) return '#88ff00';   // Vert clair: accélération moyenne
            else return '#00ff00';                      // Vert: forte accélération
        }
        
        function detectAndDisplaySpeedMarkers(points, layer, colors = null) {
    console.log('=== FONCTION UNIFIEE APPELEE ===');
    console.log('Nombre de points:', points.length);
    
    // Couleurs par défaut (meilleur tour)
    const defaultColors = {
        min: '#ff0000',  // Rouge pour creux
        max: '#00ff00'   // Vert pour sommets
    };
    
    const actualColors = colors || defaultColors;
    
    let speedMarkers = [];
    const windowSize = 8;
    
    // Détecter tous les extrema de la courbe
    for (let j = windowSize; j < points.length - windowSize; j++) {
        const speeds = [];
        for (let k = j - windowSize; k <= j + windowSize; k++) {
            speeds.push(points[k].spd);
        }
        
        const currentSpeed = points[j].spd;
        const minSpeed = Math.min(...speeds);
        const maxSpeed = Math.max(...speeds);
        
        // Creux
        if (currentSpeed === minSpeed) {
            const prevSpeed = points[Math.max(0, j - 3)].spd;
            const nextSpeed = points[Math.min(points.length - 1, j + 3)].spd;
            
            if (prevSpeed > currentSpeed && nextSpeed > currentSpeed) {
                speedMarkers.push({
                    pos: [points[j].lat, points[j].lng],
                    speed: currentSpeed,
                    type: 'min'
                });
                j += windowSize;
            }
        }
        
        // Sommet
        if (currentSpeed === maxSpeed) {
            const prevSpeed = points[Math.max(0, j - 3)].spd;
            const nextSpeed = points[Math.min(points.length - 1, j + 3)].spd;
            
            if (prevSpeed < currentSpeed && nextSpeed < currentSpeed) {
                speedMarkers.push({
                    pos: [points[j].lat, points[j].lng],
                    speed: currentSpeed,
                    type: 'max'
                });
                j += windowSize;
            }
        }
    }
    
    console.log(`Etiquettes detectees: ${speedMarkers.length} (${speedMarkers.filter(m => m.type === 'min').length} creux, ${speedMarkers.filter(m => m.type === 'max').length} sommets)`);
    
    // Afficher les étiquettes avec les couleurs appropriées
    speedMarkers.forEach((marker, index) => {
        const bgColor = marker.type === 'min' ? actualColors.min : actualColors.max;
        
        console.log(`Etiquette ${index + 1}: ${marker.type}, vitesse ${marker.speed}, couleur ${bgColor}`);
        
        const icon = L.divIcon({
            className: 'speed-marker',
            html: `<div style="background: ${bgColor}; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 13px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.5); white-space: nowrap; text-shadow: 0 1px 2px rgba(0,0,0,0.8);">${Math.round(marker.speed)}</div>`,
            iconSize: [80, 30],
            iconAnchor: [40, 15]
        });
        
        const markerObj = L.marker(marker.pos, { icon: icon, zIndexOffset: 1000 });
        markerObj.addTo(layer);
        console.log('Marker ajoute au layer');
    });
}
        
       function displayBestLap() {
    if (!map || !lapSegments || lapSegments.length === 0) return;
    
    const bestLap = lapSegments.find(lap => lap.isBestLap);
    if (!bestLap) return;
    
    console.log('=== AFFICHAGE MEILLEUR TOUR ===');
    
    // ✅ Nettoyer complètement
    clearComparisonLayers();
    if (gpsLayer && map.hasLayer(gpsLayer)) {
        map.removeLayer(gpsLayer);
    }
    if (replayMarker && map.hasLayer(replayMarker)) {
        map.removeLayer(replayMarker);
        replayMarker = null;
    }
    
    gpsLayer = L.layerGroup().addTo(map);
    
    const track = bestLap.points;
    currentReplayData = { lap: bestLap, track: track };
    
    // Dessiner d'abord la trajectoire avec les couleurs d'accélération
    for (let i = 0; i < track.length - 1; i++) {
        const prevPoint = i > 0 ? track[i - 1] : track[i];
        const p1 = track[i];
        const p2 = track[i + 1];
        const nextPoint = i < track.length - 2 ? track[i + 2] : p2;
        
        const color = getAccelerationColor(prevPoint.spd, p1.spd, nextPoint.spd);
        
        const segment = L.polyline([[p1.lat, p1.lng], [p2.lat, p2.lng]], {
            color: color,
            weight: 5,
            opacity: 0.9
        });
        
        const accel = p2.spd - p1.spd;
        const accelText = accel > 0 ? `+${accel.toFixed(1)}` : accel.toFixed(1);
        
        segment.bindPopup(`
            <strong>MEILLEUR TOUR ${bestLap.lapNumber}</strong><br>
            Temps: ${formatTime(bestLap.time)}<br>
            Vitesse: ${p1.spd.toFixed(1)} km/h<br>
            Acceleration: ${accelText} km/h<br>
            Position: ${(p1.t / 1000).toFixed(1)}s
        `);
        
        segment.addTo(gpsLayer);
    }
    
    // Utiliser la fonction réutilisable pour les étiquettes
    detectAndDisplaySpeedMarkers(track, gpsLayer);
    
    // ✅ UTILISER la nouvelle fonction pour créer le curseur
    createReplayMarker(track[0]);
    
    const bounds = L.latLngBounds(track.map(p => [p.lat, p.lng]));
    map.fitBounds(bounds, { padding: [50, 50] });
    
    displayBestLapStats(bestLap);
    initReplayControlsForBestLap(bestLap);
    createBestLapSpeedChart(bestLap);
    
    console.log('✅ Meilleur tour affiché avec curseur');
} 
        
        function displayBestLapStats(bestLap) {
            const track = bestLap.points;
            document.getElementById('track-points').textContent = track.length;
            
            let totalDistance = 0;
            for (let i = 0; i < track.length - 1; i++) {
                totalDistance += calculateDistance(track[i], track[i + 1]);
            }
            document.getElementById('track-distance').textContent = (totalDistance / 1000).toFixed(2) + ' km';
            
            const speeds = track.map(p => p.spd);
            document.getElementById('track-minspeed').textContent = Math.min(...speeds).toFixed(1) + ' km/h';
            document.getElementById('track-maxspeed').textContent = Math.max(...speeds).toFixed(1) + ' km/h';
        }
        
        function initReplayControlsForBestLap(bestLap) {
            const track = bestLap.points;
            document.getElementById('replay-controls-circuit').style.display = 'block';
            
            const slider = document.getElementById('replay-slider-circuit');
            slider.max = track.length - 1;
            slider.value = 0;
            
            const newSlider = slider.cloneNode(true);
            slider.parentNode.replaceChild(newSlider, slider);
            
            newSlider.addEventListener('input', (e) => {
                replayIndex = parseInt(e.target.value);
                updateReplayPosition();
            });
            
            replayIndex = 0;
            updateReplayPosition();

            if (replayMarker) {
        replayMarker.setOpacity(1);
    }
        }
        
       function updateReplayPosition() {
    if (!currentReplayData) {
        console.warn('Pas de données de replay');
        return;
    }
    
    const track = currentReplayData.track;
    const point = track[Math.floor(replayIndex)];
    if (!point) {
        console.warn('Point invalide:', replayIndex);
        return;
    }
    
    // ✅ Si le marker n'existe pas, le recréer
    if (!replayMarker) {
        console.log('⚠️ Curseur manquant, recréation...');
        createReplayMarker(point);
    }
    
    if (replayMarker) {
        replayMarker.setOpacity(1);
        replayMarker.setLatLng([point.lat, point.lng]);
        map.panTo([point.lat, point.lng], {animate: false});
        
        const speedTag = document.getElementById('replay-speed-tag');
        if (speedTag) {
            speedTag.style.display = 'block';
            speedTag.textContent = `${Math.round(point.spd)} km/h`;
        }
    }
    
    document.getElementById('replay-time-circuit').textContent = (point.t / 1000).toFixed(1) + 's';
    document.getElementById('replay-speed-circuit').textContent = point.spd.toFixed(1) + ' km/h';
    document.getElementById('replay-position-circuit').textContent = `${Math.floor(replayIndex) + 1}/${track.length}`;
    document.getElementById('replay-slider-circuit').value = replayIndex;
    
    if (speedChart) {
        const datasetIndex = isComparisonMode ? speedChart.data.datasets.length - 1 : 1;
        if (speedChart.data.datasets[datasetIndex]) {
            speedChart.data.datasets[datasetIndex].data = [{ x: point.t / 1000, y: point.spd }];
            speedChart.update('none');
        }
    }
    
    if (comparisonChart) {
        const cursorDatasetIndex = comparisonChart.data.datasets.length - 1;
        if (comparisonChart.data.datasets[cursorDatasetIndex]) {
            const startTime = currentReplayData.lap.points[0].t;
            comparisonChart.data.datasets[cursorDatasetIndex].data = [{ 
                x: (point.t - startTime) / 1000, 
                y: point.spd 
            }];
            comparisonChart.update('none');
        }
    }
} 
        
        function createBestLapSpeedChart(bestLap) {
            const ctx = document.getElementById('speed-chart');
            if (!ctx) return;
            
            const track = bestLap.points;
            document.getElementById('speed-chart-container').style.display = 'block';
            
            if (speedChart) speedChart.destroy();
            
            speedChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: `Meilleur Tour ${bestLap.lapNumber} - ${formatTime(bestLap.time)}`,
                            data: track.map(p => ({ x: p.t / 1000, y: p.spd })),
                            borderColor: '#1976d2',
                            backgroundColor: 'rgba(25, 118, 210, 0.1)',
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            borderWidth: 3
                        },
                        {
                            label: 'Position',
                            data: [{ x: track[0].t / 1000, y: track[0].spd }],
                            borderColor: '#ff0000',
                            backgroundColor: '#ff0000',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointBorderWidth: 3,
                            pointBorderColor: '#ffffff',
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: 2,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
    x: {
        type: 'linear',
        title: { 
            display: true, 
            text: 'Temps (s)', 
            font: { size: 12 }  // ← RÉDUIT
        },
        grid: { color: 'rgba(0, 0, 0, 0.05)' },
        ticks: { 
            font: { size: 10 }  // ← AJOUTÉ
        }
    },
    y: {
        title: { 
            display: false  // ← SUPPRIMÉ le titre "Vitesse (km/h)"
        },
        beginAtZero: true,
        grid: { color: 'rgba(0, 0, 0, 0.05)' },
        ticks: { 
            font: { size: 10 },  // ← AJOUTÉ
            callback: function(value) {
                return value + ' km/h';  // ← Affiche l'unité sur chaque valeur
            }
        }
    }
},
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { filter: function(item) { return item.text !== 'Position'; } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) return `Vitesse: ${context.parsed.y.toFixed(1)} km/h`;
                                    return null;
                                }
                            }
                        },
                        
                    },
                    onClick: (event, elements, chart) => {
                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        
                        let closestIndex = 0;
                        let minDiff = Math.abs(track[0].t / 1000 - dataX);
                        
                        for (let i = 1; i < track.length; i++) {
                            const diff = Math.abs(track[i].t / 1000 - dataX);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIndex = i;
                            }
                        }
                        
                        replayIndex = closestIndex;
                        updateReplayPosition();
                    }
                }
            });
        }
        
        function calculateDistance(p1, p2) {
            const R = 6371e3;
            const φ1 = p1.lat * Math.PI / 180;
            const φ2 = p2.lat * Math.PI / 180;
            const Δφ = (p2.lat - p1.lat) * Math.PI / 180;
            const Δλ = (p2.lng - p1.lng) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function switchMapView(view) {
            if (!map) return;
            currentMapView = view;
            map.eachLayer((layer) => { if (layer instanceof L.TileLayer) map.removeLayer(layer); });
            addMapTiles();
        }
        
        function calculateAverageSpeed() {
    // Utiliser les données GPS réelles si disponibles
    if (sessionData.gpsTrack && sessionData.gpsTrack.length > 0) {
        const speeds = sessionData.gpsTrack.map(p => p.spd);
        return speeds.reduce((a, b) => a + b, 0) / speeds.length;
    }
    
    // Fallback : calcul théorique si pas de données GPS
    if (!sessionData.times || sessionData.times.length === 0) return 0;
    const trackLength = sessionData.trackLength || 1.814;
    const avgTimeSeconds = sessionData.times.reduce((a, b) => a + b, 0) / sessionData.times.length / 1000;
    return (trackLength / avgTimeSeconds) * 3600;
}
        
        function formatTime(ms) {
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const millis = Math.floor((totalSeconds % 1) * 1000);
            return `${minutes}'${seconds.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
        }
        
        function exportData(format) {
            if (!sessionData) return;
            switch(format) {
                case 'csv': exportCSV(); break;
                case 'gpx': exportGPX(); break;
                case 'racechrono': exportRaceChrono(); break;
                case 'telemetry': exportTelemetry(); break;
            }
        }
        
        function exportCSV() {
            let csv = 'Tour,Temps (ms),Temps Formate,Ecart,Vitesse Max,Vitesse Moyenne\n';
            const bestTime = sessionData.best;
            sessionData.times.forEach((time, index) => {
                const delta = time - bestTime;
                const maxSpeed = (150 + Math.random() * 40).toFixed(1);
                const avgSpeed = calculateAverageSpeed().toFixed(1);
                csv += `${index + 1},${time},${formatTime(time)},${(delta/1000).toFixed(3)},${maxSpeed},${avgSpeed}\n`;
            });
            downloadFile(csv, `session_${sessionData.id}_data.csv`, 'text/csv');
        }
        
        function exportGPX() {
            if (!sessionData.gpsTrack) { alert('Aucune donnee GPS disponible'); return; }
            let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="GPS Race Analyzer Pro">\n';
            gpx += '  <metadata>\n    <name>Session ' + new Date(sessionData.start).toLocaleString() + '</name>\n  </metadata>\n';
            gpx += '  <trk>\n    <name>Trajectoire GPS</name>\n    <trkseg>\n';
            sessionData.gpsTrack.forEach(point => {
                const timestamp = new Date(sessionData.start + point.t).toISOString();
                gpx += `      <trkpt lat="${point.lat}" lon="${point.lng}">\n        <time>${timestamp}</time>\n`;
                gpx += `        <extensions>\n          <speed>${(point.spd / 3.6).toFixed(2)}</speed>\n        </extensions>\n      </trkpt>\n`;
            });
            gpx += '    </trkseg>\n  </trk>\n</gpx>';
            downloadFile(gpx, `session_${sessionData.id}_track.gpx`, 'application/gpx+xml');
        }
        
        async function exportRaceChrono() {
    const zip = new JSZip();
    
    // Structure RaceChrono avec métadonnées
    const sessionInfo = {
        "session": {
            "id": sessionData.id,
            "name": "GPS Session " + new Date(sessionData.start).toLocaleDateString(),
            "date": new Date(sessionData.start).toISOString(),
            "track": "Circuit détecté",
            "vehicle": "Non spécifié",
            "driver": "Pilote"
        }
    };
    
    // Données de tours
    const lapsData = {
        "laps": sessionData.times.map((time, index) => ({
            "number": index + 1,
            "time": time / 1000,
            "sectors": [],
            "valid": true
        })),
        "bestLapTime": sessionData.best / 1000,
        "bestLapNumber": sessionData.times.indexOf(sessionData.best) + 1
    };
    
    // Données GPS (telemetry)
    const telemetryData = {
        "telemetry": sessionData.gpsTrack ? sessionData.gpsTrack.map(p => ({
            "timestamp": p.t,
            "latitude": p.lat,
            "longitude": p.lng,
            "speed": p.spd / 3.6, // Conversion en m/s
            "altitude": 0
        })) : []
    };
    
    // Ajouter les fichiers au ZIP
    zip.file("session.json", JSON.stringify(sessionInfo, null, 2));
    zip.file("laps.json", JSON.stringify(lapsData, null, 2));
    zip.file("telemetry.json", JSON.stringify(telemetryData, null, 2));
    
    // Générer le fichier .rcz (ZIP)
    const content = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 9 }
    });
    
    // Télécharger
    downloadFile(content, `session_${sessionData.id}_racechrono.rcz`, 'application/zip');
}
        
        function exportTelemetry() {
            if (!sessionData.gpsTrack) { alert('Aucune donnee de telemetrie disponible'); return; }
            let csv = 'Temps (ms),Latitude,Longitude,Vitesse (km/h),Timestamp\n';
            sessionData.gpsTrack.forEach(point => {
                csv += `${point.t},${point.lat},${point.lng},${point.spd},${sessionData.start + point.t}\n`;
            });
            downloadFile(csv, `session_${sessionData.id}_telemetry.csv`, 'text/csv');
        }
        
        function downloadFile(content, filename, type) {
    let blob;
    
    // Si content est déjà un Blob, l'utiliser directement
    if (content instanceof Blob) {
        blob = content;
    } else {
        // Sinon créer un Blob depuis le contenu texte
        blob = new Blob([content], { type: type });
    }
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
        
        function replayControl(action) {
            if (!currentReplayData) return;
            const track = currentReplayData.track;
            
            switch(action) {
                case 'play':
                    if (replayInterval) clearInterval(replayInterval);
                    replayInterval = setInterval(() => {
                        replayIndex += replaySpeed;
                        if (replayIndex >= track.length - 1) {
                            replayIndex = track.length - 1;
                            clearInterval(replayInterval);
                            replayInterval = null;
                        }
                        updateReplayPosition();
                    }, 50);
                    break;
                case 'pause':
                    if (replayInterval) { clearInterval(replayInterval); replayInterval = null; }
                    break;
                case 'reset':
                    if (replayInterval) { clearInterval(replayInterval); replayInterval = null; }
                    replayIndex = 0;
                    updateReplayPosition();
                    break;
            }
        }
        
        function changeReplaySpeed(speed) { replaySpeed = speed; }
        
        function analyzeTurns() {
            if (!sessionData || !sessionData.gpsTrack) {
                document.getElementById('turns-grid').innerHTML = '<p style="text-align: center; padding: 50px; color: #999;">Aucune donnee GPS disponible</p>';
                return;
            }
            
            const track = sessionData.gpsTrack;
            const turns = detectTurns(track);
            const turnsGrid = document.getElementById('turns-grid');
            turnsGrid.innerHTML = '';
            
            turns.forEach((turn, index) => {
                const card = document.createElement('div');
                card.className = 'turn-card';
                card.innerHTML = `
                    <h4>Virage ${index + 1}</h4>
                    <div class="turn-stat"><span>Vitesse d'entree</span><strong>${turn.entrySpeed.toFixed(1)} km/h</strong></div>
                    <div class="turn-stat"><span>Vitesse a l'apex</span><strong>${turn.apexSpeed.toFixed(1)} km/h</strong></div>
                    <div class="turn-stat"><span>Vitesse de sortie</span><strong>${turn.exitSpeed.toFixed(1)} km/h</strong></div>
                    <div class="turn-stat"><span>Perte de vitesse</span><strong>${(turn.entrySpeed - turn.apexSpeed).toFixed(1)} km/h</strong></div>
                `;
                turnsGrid.appendChild(card);
            });
        }
        
        function detectTurns(track) {
            const turns = [];
            const minSpeedDrop = 40;
            
            for (let i = 10; i < track.length - 10; i++) {
                const prevSpeed = track[i - 5].spd;
                const currentSpeed = track[i].spd;
                const nextSpeed = track[i + 5].spd;
                
                if (prevSpeed - currentSpeed > minSpeedDrop && nextSpeed > currentSpeed) {
                    turns.push({
                        index: i,
                        entrySpeed: prevSpeed,
                        apexSpeed: currentSpeed,
                        exitSpeed: nextSpeed,
                        position: { lat: track[i].lat, lng: track[i].lng }
                    });
                    i += 15;
                }
            }
            return turns.slice(0, 8);
        }
        
        function segmentLapsFromGPSTrack() {
            if (!sessionData || !sessionData.gpsTrack || !sessionData.times) return;
            
            const track = sessionData.gpsTrack;
            const lapTimes = sessionData.times;
            lapSegments = [];
            
            const pointsPerLap = Math.floor(track.length / lapTimes.length);
            
            for (let lapIndex = 0; lapIndex < lapTimes.length; lapIndex++) {
                const startIndex = lapIndex * pointsPerLap;
                const endIndex = (lapIndex === lapTimes.length - 1) ? track.length : (lapIndex + 1) * pointsPerLap;
                const lapPoints = track.slice(startIndex, endIndex);
                
                if (lapPoints.length > 0) {
                    lapSegments.push({
                        lapNumber: lapIndex + 1,
                        time: lapTimes[lapIndex],
                        points: lapPoints,
                        isBestLap: lapTimes[lapIndex] === sessionData.best
                    });
                }
            }
            populateLapSelectors();
        }
        
        function populateLapSelectors() {
    const selector1 = document.getElementById('compare-lap1');
    const selector2 = document.getElementById('compare-lap2');
    if (!selector1 || !selector2) return;
    
    console.log('Remplissage des sélecteurs avec', lapSegments.length, 'tours');
    
    // Supprimer les anciens event listeners
    const newSelector1 = selector1.cloneNode(false);
    const newSelector2 = selector2.cloneNode(false);
    selector1.parentNode.replaceChild(newSelector1, selector1);
    selector2.parentNode.replaceChild(newSelector2, selector2);
    
    const bestLapIndex = lapSegments.findIndex(lap => lap.isBestLap);
    
    // Remplir sélecteur 1
    newSelector1.innerHTML = '<option value="">-- Sélectionner --</option>';
    lapSegments.forEach((lap, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Tour ${lap.lapNumber} - ${formatTime(lap.time)}${lap.isBestLap ? ' ⭐' : ''}`;
        newSelector1.appendChild(option);
    });
    
    // Remplir sélecteur 2
    newSelector2.innerHTML = '<option value="">-- Sélectionner --</option>';
    lapSegments.forEach((lap, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Tour ${lap.lapNumber} - ${formatTime(lap.time)}${lap.isBestLap ? ' ⭐' : ''}`;
        newSelector2.appendChild(option);
    });
    
    // Pré-sélectionner le meilleur tour
    if (bestLapIndex !== -1) {
        newSelector1.value = bestLapIndex;
    }
    
    // Event listeners
    newSelector1.addEventListener('change', function() {
        console.log('Selector 1 changé:', this.value);
        updateSelector2Options();
    });
    
    newSelector2.addEventListener('change', function() {
        console.log('Selector 2 changé:', this.value);
        updateSelector1Options();
    });
    
    // ✅ NOUVEAU : Remplir aussi le sélecteur tour unique
    populateSingleLapSelector();
    
    console.log('✅ Tous les sélecteurs configurés');
}

// ✅ NOUVELLE FONCTION : Mettre à jour les options du sélecteur 1
function updateSelector1Options() {
    const selector1 = document.getElementById('compare-lap1');
    const selector2 = document.getElementById('compare-lap2');
    const selected2 = selector2.value;
    
    // Désactiver l'option déjà sélectionnée dans selector2
    Array.from(selector1.options).forEach(option => {
        if (option.value === selected2 && option.value !== '') {
            option.disabled = true;
            option.textContent = option.textContent.replace(' ❌', '') + ' ❌';
        } else {
            option.disabled = false;
            option.textContent = option.textContent.replace(' ❌', '');
        }
    });
}
        
function populateSingleLapSelector() {
    const selector = document.getElementById('single-lap-selector');
    if (!selector) return;
    
    console.log('Remplissage sélecteur tour unique');
    
    // Supprimer les anciens event listeners
    const newSelector = selector.cloneNode(false);
    selector.parentNode.replaceChild(newSelector, selector);
    
    const bestLapIndex = lapSegments.findIndex(lap => lap.isBestLap);
    
    // Remplir le sélecteur
    newSelector.innerHTML = '<option value="">-- Sélectionner --</option>';
    lapSegments.forEach((lap, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Tour ${lap.lapNumber} - ${formatTime(lap.time)}${lap.isBestLap ? ' ⭐ (Meilleur)' : ''}`;
        newSelector.appendChild(option);
    });
    
    // Pré-sélectionner le meilleur tour
    if (bestLapIndex !== -1) {
        newSelector.value = bestLapIndex;
    }
    
    console.log('✅ Sélecteur tour unique configuré');
}

        function compareSelectedLaps() {
    const lap1Index = document.getElementById('compare-lap1').value;
    const lap2Index = document.getElementById('compare-lap2').value;
    
    // ✅ VALIDATION AMÉLIORÉE
    if (lap1Index === '' || lap2Index === '') {
        alert('⚠️ Veuillez sélectionner deux tours à comparer');
        return;
    }
    
    if (lap1Index === lap2Index) {
        alert('⚠️ Veuillez sélectionner deux tours différents');
        return;
    }
    
    const selectedLaps = [lap1Index, lap2Index];
    
    if (!map) {
        initMap();
        setTimeout(() => displayComparisonOnMap(selectedLaps), 500);
    } else {
        displayComparisonOnMap(selectedLaps);
    }
    
    createComparisonSpeedChart(selectedLaps);
    isComparisonMode = true;
}
        
     function displayComparisonOnMap(selectedLapIndexes) {
    if (!map) return;
    
    console.log('=== AFFICHAGE COMPARAISON ===');
    console.log('Tours à comparer:', selectedLapIndexes);
    
    // ✅ NETTOYAGE COMPLET : supprimer TOUS les layers
    clearComparisonLayers();
    
    // ✅ IMPORTANT : Supprimer aussi le layer GPS principal
    if (gpsLayer && map.hasLayer(gpsLayer)) {
        map.removeLayer(gpsLayer);
        console.log('Layer GPS principal supprimé');
    }
    
    // ✅ SUPPRIMER le marker de replay existant
    if (replayMarker && map.hasLayer(replayMarker)) {
        map.removeLayer(replayMarker);
        replayMarker = null;
        console.log('Marker de replay supprimé');
    }
    
    const colors = ['#4caf50', '#1976d2'];
    const legendItems = [];
    
    selectedLapIndexes.forEach((lapIndex, i) => {
        const lap = lapSegments[parseInt(lapIndex)];
        if (!lap) {
            console.warn('Tour introuvable:', lapIndex);
            return;
        }
        
        console.log(`Affichage tour ${lap.lapNumber} (couleur: ${colors[i]})`);
        
        const color = colors[i];
        const points = lap.points;
        const lapLayer = L.layerGroup().addTo(map);
        comparisonLayers.push(lapLayer);
        
        if (i === 0) {
            // Premier tour (généralement le meilleur) avec couleurs d'accélération
            for (let j = 0; j < points.length - 1; j++) {
                const prevPoint = j > 0 ? points[j - 1] : points[j];
                const p1 = points[j];
                const p2 = points[j + 1];
                const nextPoint = j < points.length - 2 ? points[j + 2] : p2;
                
                const segmentColor = getAccelerationColor(prevPoint.spd, p1.spd, nextPoint.spd);
                const polyline = L.polyline([[p1.lat, p1.lng], [p2.lat, p2.lng]], { 
                    color: segmentColor, 
                    weight: 5, 
                    opacity: 0.9 
                });
                polyline.bindPopup(`<strong>Tour ${lap.lapNumber}</strong><br>Temps: ${formatTime(lap.time)}<br>Vitesse: ${p1.spd.toFixed(1)} km/h`);
                polyline.addTo(lapLayer);
            }
            
            detectAndDisplaySpeedMarkers(points, lapLayer);
        } else {
            // Deuxième tour avec couleurs d'accélération et pointillés
            for (let j = 0; j < points.length - 1; j++) {
                const prevPoint = j > 0 ? points[j - 1] : points[j];
                const p1 = points[j];
                const p2 = points[j + 1];
                const nextPoint = j < points.length - 2 ? points[j + 2] : p2;
                
                const segmentColor = getAccelerationColor(prevPoint.spd, p1.spd, nextPoint.spd);
                
                const polyline = L.polyline([[p1.lat, p1.lng], [p2.lat, p2.lng]], { 
                    color: segmentColor, 
                    weight: 4, 
                    opacity: 0.7,
                    dashArray: '10, 5'
                });
                
                const accel = p2.spd - p1.spd;
                const accelText = accel > 0 ? `+${accel.toFixed(1)}` : accel.toFixed(1);
                
                polyline.bindPopup(`
                    <strong>Tour ${lap.lapNumber}</strong><br>
                    Temps: ${formatTime(lap.time)}<br>
                    Vitesse: ${p1.spd.toFixed(1)} km/h<br>
                    Accélération: ${accelText} km/h<br>
                    Position: ${(p1.t / 1000).toFixed(1)}s
                `);
                
                polyline.addTo(lapLayer);
            }
            
            const comparisonColors = {
                min: '#ff8800',  
                max: '#0F71D1'   
            };
            detectAndDisplaySpeedMarkers(points, lapLayer, comparisonColors);
        }
        
        // Marqueur de départ
        const startIcon = L.divIcon({
            className: 'speed-marker',
            html: `<div style="background: ${color}; color: white; padding: 3px 8px; border-radius: 10px; font-weight: bold; font-size: 11px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.4);">${lap.isBestLap ? '★' : 'T' + lap.lapNumber}</div>`,
            iconSize: [30, 20],
            iconAnchor: [15, 10]
        });
        L.marker([points[0].lat, points[0].lng], { icon: startIcon }).addTo(lapLayer);
        
        legendItems.push({ 
            color: color, 
            label: `${lap.isBestLap ? '★ ' : ''}Tour ${lap.lapNumber} - ${formatTime(lap.time)}`, 
            dashArray: i === 0 ? null : '10, 5' 
        });
    });
    
    displayComparisonLegend(legendItems);
    
    // Ajuster la vue sur les deux tours
    const allPoints = selectedLapIndexes
        .map(idx => lapSegments[parseInt(idx)])
        .filter(lap => lap)
        .flatMap(lap => lap.points)
        .map(p => [p.lat, p.lng]);
    
    if (allPoints.length > 0) {
        const bounds = L.latLngBounds(allPoints);
        map.fitBounds(bounds, { padding: [50, 50] });
    }
    
    // ✅ RECRÉER le curseur rouge pour le premier tour
    const firstLap = lapSegments[parseInt(selectedLapIndexes[0])];
    if (firstLap) {
        currentReplayData = { lap: firstLap, track: firstLap.points };
        
        // Créer un nouveau marker de replay
        createReplayMarker(firstLap.points[0]);
        
        document.getElementById('replay-controls-circuit').style.display = 'block';
        initReplayControlsForBestLap(firstLap);
    }
    
    console.log('✅ Comparaison affichée - 2 tours seulement');
}   
function createReplayMarker(initialPoint) {
    console.log('🔴 Création du curseur rouge...');
    
    // Supprimer l'ancien marker s'il existe
    if (replayMarker && map.hasLayer(replayMarker)) {
        map.removeLayer(replayMarker);
        replayMarker = null;
    }
    
    const markerIcon = L.divIcon({
        className: 'replay-marker',
        html: `
            <div class="replay-marker-dot" style="width: 18px; height: 18px; background: #ff0000; border: 3px solid white; border-radius: 50%; box-shadow: 0 3px 10px rgba(0,0,0,0.8); position: relative; z-index: 1000;"></div>
            <div class="replay-speed-tag" id="replay-speed-tag" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #ff0000; color: white; padding: 5px 12px; border-radius: 15px; font-weight: bold; font-size: 14px; white-space: nowrap; box-shadow: 0 3px 10px rgba(0,0,0,0.8); opacity: 0; visibility: hidden; pointer-events: none; margin-bottom: 8px; border: 2px solid white; z-index: 1001; min-width: 65px; text-align: center;"></div>
        `,
        iconSize: [18, 18],
        iconAnchor: [9, 9]
    });
    
    replayMarker = L.marker([initialPoint.lat, initialPoint.lng], { 
        icon: markerIcon, 
        opacity: 1,
        zIndexOffset: 2000 
    }).addTo(map);
    
    console.log('✅ Curseur rouge créé');
    return replayMarker;
}
        function displaySelectedSingleLap() {
    console.log('=== AFFICHAGE TOUR UNIQUE ===');
    
    const selector = document.getElementById('single-lap-selector');
    if (!selector) {
        console.error('❌ Sélecteur introuvable');
        return;
    }
    
    const lapIndex = selector.value;
    console.log('Tour sélectionné:', lapIndex);
    
    if (lapIndex === '') {
        alert('⚠️ Veuillez sélectionner un tour à afficher');
        return;
    }
    
    // Afficher le tour sélectionné
    displaySingleLap(parseInt(lapIndex));
}

function displaySingleLap(lapIndex) {
    if (!map || !lapSegments || lapIndex < 0 || lapIndex >= lapSegments.length) {
        console.error('❌ Index de tour invalide');
        return;
    }
    
    const selectedLap = lapSegments[lapIndex];
    console.log('=== AFFICHAGE TOUR UNIQUE ===');
    console.log('Tour', selectedLap.lapNumber);
    
    // ✅ Nettoyer TOUS les layers
    clearComparisonLayers();
    if (gpsLayer && map.hasLayer(gpsLayer)) {
        map.removeLayer(gpsLayer);
    }
    if (replayMarker && map.hasLayer(replayMarker)) {
        map.removeLayer(replayMarker);
        replayMarker = null;
    }
    
    // Créer un nouveau layer
    gpsLayer = L.layerGroup().addTo(map);
    
    const track = selectedLap.points;
    currentReplayData = { lap: selectedLap, track: track };
    
    // Dessiner la trajectoire avec couleurs d'accélération
    for (let i = 0; i < track.length - 1; i++) {
        const prevPoint = i > 0 ? track[i - 1] : track[i];
        const p1 = track[i];
        const p2 = track[i + 1];
        const nextPoint = i < track.length - 2 ? track[i + 2] : p2;
        
        const color = getAccelerationColor(prevPoint.spd, p1.spd, nextPoint.spd);
        
        const segment = L.polyline([[p1.lat, p1.lng], [p2.lat, p2.lng]], {
            color: color,
            weight: 5,
            opacity: 0.9
        });
        
        const accel = p2.spd - p1.spd;
        const accelText = accel > 0 ? `+${accel.toFixed(1)}` : accel.toFixed(1);
        
        segment.bindPopup(`
            <strong>TOUR ${selectedLap.lapNumber}${selectedLap.isBestLap ? ' ⭐' : ''}</strong><br>
            Temps: ${formatTime(selectedLap.time)}<br>
            Vitesse: ${p1.spd.toFixed(1)} km/h<br>
            Accélération: ${accelText} km/h<br>
            Position: ${(p1.t / 1000).toFixed(1)}s
        `);
        
        segment.addTo(gpsLayer);
    }
    
    // Afficher les étiquettes de vitesse
    detectAndDisplaySpeedMarkers(track, gpsLayer);
    
    // ✅ UTILISER la nouvelle fonction pour créer le curseur
    createReplayMarker(track[0]);
    
    // Ajuster la vue
    const bounds = L.latLngBounds(track.map(p => [p.lat, p.lng]));
    map.fitBounds(bounds, { padding: [50, 50] });
    
    // Afficher les statistiques du tour
    displayLapStats(selectedLap);
    
    // Initialiser les contrôles de replay
    initReplayControlsForLap(selectedLap);
    
    // Créer le graphique de vitesse
    createLapSpeedChart(selectedLap);
    
    // Masquer la légende de comparaison
    document.getElementById('comparison-legend').style.display = 'none';
    
    isComparisonMode = false;
    
    console.log('✅ Tour unique affiché avec curseur');
}

function displayLapStats(lap) {
    const track = lap.points;
    document.getElementById('track-points').textContent = track.length;
    
    let totalDistance = 0;
    for (let i = 0; i < track.length - 1; i++) {
        totalDistance += calculateDistance(track[i], track[i + 1]);
    }
    document.getElementById('track-distance').textContent = (totalDistance / 1000).toFixed(2) + ' km';
    
    const speeds = track.map(p => p.spd);
    document.getElementById('track-minspeed').textContent = Math.min(...speeds).toFixed(1) + ' km/h';
    document.getElementById('track-maxspeed').textContent = Math.max(...speeds).toFixed(1) + ' km/h';
}

function initReplayControlsForLap(lap) {
    const track = lap.points;
    document.getElementById('replay-controls-circuit').style.display = 'block';
    
    const slider = document.getElementById('replay-slider-circuit');
    slider.max = track.length - 1;
    slider.value = 0;
    
    const newSlider = slider.cloneNode(true);
    slider.parentNode.replaceChild(newSlider, slider);
    
    newSlider.addEventListener('input', (e) => {
        replayIndex = parseInt(e.target.value);
        updateReplayPosition();
    });
    
    replayIndex = 0;
    updateReplayPosition();

    if (replayMarker) {
        replayMarker.setOpacity(1);
    }
}

function createLapSpeedChart(lap) {
    const ctx = document.getElementById('speed-chart');
    if (!ctx) return;
    
    const track = lap.points;
    document.getElementById('speed-chart-container').style.display = 'block';
    
    if (speedChart) speedChart.destroy();
    if (comparisonChart) comparisonChart.destroy();
    comparisonChart = null;
    
    speedChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: `Tour ${lap.lapNumber} - ${formatTime(lap.time)}${lap.isBestLap ? ' ⭐' : ''}`,
                    data: track.map(p => ({ x: p.t / 1000, y: p.spd })),
                    borderColor: lap.isBestLap ? '#4caf50' : '#1976d2',
                    backgroundColor: lap.isBestLap ? 'rgba(76, 175, 80, 0.1)' : 'rgba(25, 118, 210, 0.1)',
                    tension: 0.4,
                    fill: true,
                    pointRadius: 0,
                    borderWidth: 3
                },
                {
                    label: 'Position',
                    data: [{ x: track[0].t / 1000, y: track[0].spd }],
                    borderColor: '#ff0000',
                    backgroundColor: '#ff0000',
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    pointBorderWidth: 3,
                    pointBorderColor: '#ffffff',
                    showLine: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            aspectRatio: 2,
            interaction: { mode: 'index', intersect: false },
            scales: {
                x: {
                    type: 'linear',
                    title: { display: true, text: 'Temps (s)', font: { size: 12 } },
                    grid: { color: 'rgba(0, 0, 0, 0.05)' },
                    ticks: { font: { size: 10 } }
                },
                y: {
                    title: { display: false },
                    beginAtZero: true,
                    grid: { color: 'rgba(0, 0, 0, 0.05)' },
                    ticks: { 
                        font: { size: 10 },
                        callback: function(value) {
                            return value + ' km/h';
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: { filter: function(item) { return item.text !== 'Position'; } }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.datasetIndex === 0) return `Vitesse: ${context.parsed.y.toFixed(1)} km/h`;
                            return null;
                        }
                    }
                }
            },
            onClick: (event, elements, chart) => {
                const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                
                let closestIndex = 0;
                let minDiff = Math.abs(track[0].t / 1000 - dataX);
                
                for (let i = 1; i < track.length; i++) {
                    const diff = Math.abs(track[i].t / 1000 - dataX);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                
                replayIndex = closestIndex;
                updateReplayPosition();
            }
        }
    });
}
        
        function displayComparisonLegend(items) {
    const legend = document.getElementById('comparison-legend');
    const itemsContainer = document.getElementById('legend-items');
    
    itemsContainer.innerHTML = items.map(item => `
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 40px; height: 3px; background: ${item.color}; ${item.dashArray ? 'background: repeating-linear-gradient(90deg, ' + item.color + ' 0px, ' + item.color + ' 10px, transparent 10px, transparent 15px);' : ''}"></div>
            <span style="font-size: 0.9rem; color: var(--text-primary);">${item.label}</span>
        </div>
    `).join('');
    legend.style.display = 'block';
}
        
        function createComparisonSpeedChart(selectedLapIndexes) {
            const container = document.getElementById('speed-chart-container');
            const canvas = document.getElementById('speed-chart');
            if (!container || !canvas) return;
            
            container.style.display = 'block';
            if (speedChart) { speedChart.destroy(); speedChart = null; }
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = [{ border: '#4caf50', bg: 'rgba(76, 175, 80, 0.1)' }, { border: '#1976d2', bg: 'rgba(25, 118, 210, 0.1)' }];
            
            const datasets = selectedLapIndexes.map((lapIndex, i) => {
                const lap = lapSegments[parseInt(lapIndex)];
                if (!lap) return null;
                
                const startTime = lap.points[0].t;
                const normalizedData = lap.points.map(p => ({ x: (p.t - startTime) / 1000, y: p.spd }));
                
                return {
                    label: `${lap.isBestLap ? '★ ' : ''}Tour ${lap.lapNumber} - ${formatTime(lap.time)}`,
                    data: normalizedData,
                    borderColor: colors[i].border,
                    backgroundColor: colors[i].bg,
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 0
                };
            }).filter(d => d !== null);
            
            const firstLap = lapSegments[parseInt(selectedLapIndexes[0])];
            if (firstLap && firstLap.points.length > 0) {
                datasets.push({
                    label: 'Position Actuelle',
                    data: [{ x: 0, y: firstLap.points[0].spd }],
                    borderColor: '#ff0000',
                    backgroundColor: '#ff0000',
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    pointBorderWidth: 3,
                    pointBorderColor: '#ffffff',
                    showLine: false,
                    order: 999
                });
            }
            
            comparisonChart = new Chart(canvas, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Temps depuis debut du tour (s)', font: { size: 14 } },
                            grid: { color: 'rgba(0, 0, 0, 0.05)' }
                        },
                        y: {
                            title: { display: true, text: 'Vitesse (km/h)', font: { size: 14 } },
                            beginAtZero: true,
                            grid: { color: 'rgba(0, 0, 0, 0.05)' }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { filter: function(item) { return item.text !== 'Position Actuelle'; } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label === 'Position Actuelle') return null;
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} km/h`;
                                }
                            }
                        },
                        
                    },
                    onClick: (event, elements, chart) => {
                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        
                        const firstLap = lapSegments[parseInt(selectedLapIndexes[0])];
                        if (firstLap) {
                            const track = firstLap.points;
                            const clickedIndex = Math.round((dataX / (firstLap.time / 1000)) * (track.length - 1));
                            if (clickedIndex >= 0 && clickedIndex < track.length) {
                                replayIndex = clickedIndex;
                                updateReplayPosition();
                            }
                        }
                    }
                }
            });
        }
        
function clearComparisonLayers() {
    console.log('Nettoyage des layers de comparaison...');
    
    if (comparisonLayers && comparisonLayers.length > 0) {
        comparisonLayers.forEach(layer => {
            if (map && map.hasLayer(layer)) {
                map.removeLayer(layer);
            }
        });
        comparisonLayers = [];
        console.log('✅ Layers nettoyés');
    } else {
        console.log('Aucun layer à nettoyer');
    }
}

        function clearComparison() {
    console.log('=== RÉINITIALISATION ===');
    
    clearComparisonLayers();
    
    const selector1 = document.getElementById('compare-lap1');
    const selector2 = document.getElementById('compare-lap2');
    const singleSelector = document.getElementById('single-lap-selector');
    
    // Réinitialiser tous les sélecteurs
    if (selector1) {
        Array.from(selector1.options).forEach(option => {
            option.disabled = false;
            option.textContent = option.textContent.replace(' ❌', '');
        });
        const bestLapIndex = lapSegments.findIndex(lap => lap.isBestLap);
        if (bestLapIndex !== -1) selector1.value = bestLapIndex;
    }
    
    if (selector2) {
        Array.from(selector2.options).forEach(option => {
            option.disabled = false;
            option.textContent = option.textContent.replace(' ❌', '');
        });
        selector2.value = '';
    }
    
    if (singleSelector) {
        const bestLapIndex = lapSegments.findIndex(lap => lap.isBestLap);
        if (bestLapIndex !== -1) singleSelector.value = bestLapIndex;
    }
    
    document.getElementById('comparison-legend').style.display = 'none';
    
    if (comparisonChart) {
        comparisonChart.destroy();
        comparisonChart = null;
    }
    
    if (speedChart) {
        speedChart.destroy();
        speedChart = null;
    }
    
    isComparisonMode = false;
    
    console.log('Réaffichage du meilleur tour...');
    displayBestLap();
    
    console.log('✅ Réinitialisation effectuée');
}    
        
    </script>
<script>
// ==========================================
// EXPORT PDF COMPLET - VERSION ROBUSTE
// ==========================================
// Cette version gère tous les cas de données manquantes

function exportToPDF() {
    if (!sessionData) {
        alert('❌ Aucune session chargée');
        return;
    }

    // Vérifier que jsPDF est chargé
    if (typeof window.jspdf === 'undefined') {
        alert('❌ Erreur: Bibliothèque jsPDF non chargée.\n\nAssurez-vous d\'avoir ajouté les scripts jsPDF.');
        return;
    }

    try {
        // Créer le document PDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4');
        
        let yPosition = 20;
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;

        // ========== FONCTIONS AUXILIAIRES POUR DONNÉES SÉCURISÉES ==========
        
        function safeNumber(value, decimals = 1) {
            if (value === undefined || value === null || isNaN(value)) return '-';
            return Number(value).toFixed(decimals);
        }
        
        function safeValue(value, fallback = '-') {
            return value !== undefined && value !== null ? value : fallback;
        }
        
        // Calculer les statistiques de manière sécurisée
        const times = sessionData.times || [];
        const bestTime = sessionData.best || (times.length > 0 ? Math.min(...times) : 0);
        const totalTime = times.reduce((a, b) => a + b, 0);
        
        // Vitesse max - essayer plusieurs sources
        let maxSpeed = sessionData.maxSpd || sessionData.maxSpeed;
        if (!maxSpeed && sessionData.gpsTrack && sessionData.gpsTrack.length > 0) {
            const speeds = sessionData.gpsTrack.map(p => p.spd || p.speed || 0);
            maxSpeed = Math.max(...speeds);
        }
        if (!maxSpeed) maxSpeed = 0;
        
        // Vitesse moyenne - essayer plusieurs sources
        let avgSpeed = sessionData.avgSpd || sessionData.avgSpeed;
        if (!avgSpeed && sessionData.gpsTrack && sessionData.gpsTrack.length > 0) {
            const speeds = sessionData.gpsTrack.map(p => p.spd || p.speed || 0).filter(s => s > 0);
            avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
        }
        if (!avgSpeed) avgSpeed = 0;
        
        // Distance - essayer plusieurs sources
        let distance = sessionData.dist || sessionData.distance || sessionData.trackLength;
        if (!distance && sessionData.gpsTrack && sessionData.gpsTrack.length > 1) {
            distance = calculateTotalDistance(sessionData.gpsTrack);
        }
        if (!distance) distance = 0;
        
        // Nombre de tours
        const lapsCount = sessionData.laps || times.length || 0;

        // ========== PAGE 1: EN-TÊTE ET STATISTIQUES ==========
        
        doc.setFontSize(24);
        doc.setTextColor(25, 118, 210);
        doc.text('GPS LapTimer', margin, yPosition);
        
        yPosition += 8;
        doc.setFontSize(16);
        doc.text('Rapport de Session', margin, yPosition);
        
        yPosition += 10;
        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        const sessionDate = sessionData.date || sessionData.id || 'Session';
        doc.text(`Session: ${sessionDate}`, margin, yPosition);
        
        yPosition += 15;
        
        // Statistiques principales
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 0);
        doc.setFont(undefined, 'bold');
        doc.text('Statistiques Générales', margin, yPosition);
        
        yPosition += 8;
        doc.setFontSize(10);
        doc.setFont(undefined, 'normal');
        
        const stats = [
            ['Tours Terminés', lapsCount],
            ['Meilleur Temps', times.length > 0 ? formatTime(bestTime) : '-'],
            ['Vitesse Max', `${safeNumber(maxSpeed, 1)} km/h`],
            ['Vitesse Moyenne', `${safeNumber(avgSpeed, 1)} km/h`],
            ['Distance Totale', `${safeNumber(distance, 2)} km`],
            ['Temps Total', times.length > 0 ? formatTime(totalTime) : '-']
        ];
        
        stats.forEach(([label, value]) => {
            doc.setFont(undefined, 'bold');
            doc.text(`${label}:`, margin, yPosition);
            doc.setFont(undefined, 'normal');
            doc.text(String(value), margin + 60, yPosition);
            yPosition += 7;
        });
        
        // ========== TABLEAU DES TOURS ==========
        
        if (times.length > 0) {
            yPosition += 10;
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(25, 118, 210);
            doc.text('Détail des Tours', margin, yPosition);
            yPosition += 5;
            
            const lapsData = times.map((time, index) => {
                const delta = time - bestTime;
                
                // Récupérer les vitesses du tour si disponibles
                let lapMaxSpeed = '-';
                let lapAvgSpeed = '-';
                
                if (sessionData.lapsSpeed && sessionData.lapsSpeed[index]) {
                    lapMaxSpeed = `${safeNumber(sessionData.lapsSpeed[index].max, 1)} km/h`;
                    lapAvgSpeed = `${safeNumber(sessionData.lapsSpeed[index].avg, 1)} km/h`;
                } else {
                    lapMaxSpeed = `${safeNumber(maxSpeed, 1)} km/h`;
                    lapAvgSpeed = `${safeNumber(avgSpeed, 1)} km/h`;
                }
                
                return [
                    `T${index + 1}`,
                    formatTime(time),
                    delta === 0 ? 'RECORD' : `+${(delta/1000).toFixed(3)}s`,
                    lapMaxSpeed,
                    lapAvgSpeed
                ];
            });
            
            doc.autoTable({
                startY: yPosition,
                head: [['Tour', 'Temps', 'Écart', 'V.Max', 'V.Moy']],
                body: lapsData,
                margin: { left: margin, right: margin },
                styles: { 
                    fontSize: 9, 
                    cellPadding: 3,
                    overflow: 'linebreak'
                },
                headStyles: { 
                    fillColor: [25, 118, 210], 
                    textColor: 255,
                    fontStyle: 'bold'
                },
                alternateRowStyles: { 
                    fillColor: [245, 245, 245] 
                },
                columnStyles: {
                    0: { cellWidth: 20 },
                    1: { cellWidth: 35 },
                    2: { cellWidth: 35 },
                    3: { cellWidth: 30 },
                    4: { cellWidth: 30 }
                }
            });
        }
        
        // ========== PAGE 2: ANALYSE ==========
        
        if (times.length > 0) {
            doc.addPage();
            yPosition = 20;
            
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(25, 118, 210);
            doc.text('Analyse de Performance', margin, yPosition);
            yPosition += 10;
            
            // Calculs statistiques
            const avg = times.reduce((a, b) => a + b, 0) / times.length;
            const variance = times.reduce((sum, time) => sum + Math.pow(time - avg, 2), 0) / times.length;
            const stdDev = Math.sqrt(variance);
            const consistency = Math.max(0, 100 - (stdDev / avg) * 100);
            
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(0, 0, 0);
            
            const analysisData = [
                ['Temps moyen', formatTime(avg)],
                ['Écart-type', `${(stdDev/1000).toFixed(3)}s`],
                ['Consistance', `${consistency.toFixed(1)}%`],
                ['Premier tour', formatTime(times[0])],
                ['Dernier tour', formatTime(times[times.length - 1])],
                ['Amélioration', `${((times[0] - bestTime) / 1000).toFixed(3)}s`],
                ['Points GPS', safeValue(sessionData.points || (sessionData.gpsTrack ? sessionData.gpsTrack.length : null))]
            ];
            
            analysisData.forEach(([label, value]) => {
                doc.setFont(undefined, 'bold');
                doc.text(`${label}:`, margin, yPosition);
                doc.setFont(undefined, 'normal');
                doc.text(String(value), margin + 60, yPosition);
                yPosition += 7;
            });
            
            // Barre de consistance visuelle
            yPosition += 5;
            doc.setFillColor(224, 224, 224);
            doc.rect(margin + 60, yPosition - 5, 100, 8, 'F');
            doc.setFillColor(76, 175, 80);
            doc.rect(margin + 60, yPosition - 5, consistency, 8, 'F');
            
            // ========== PROGRESSION ==========
            
            yPosition += 15;
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(25, 118, 210);
            doc.text('Progression par Tour', margin, yPosition);
            yPosition += 8;
            
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(0, 0, 0);
            
            times.forEach((time, index) => {
                if (yPosition > pageHeight - 30) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                const delta = time - bestTime;
                const percentage = Math.min(100, Math.max(10, (delta / bestTime) * 100 + 85));
                
                // Texte du tour
                doc.text(`T${index + 1}:`, margin, yPosition);
                doc.text(formatTime(time), margin + 15, yPosition);
                
                const deltaText = delta === 0 ? '(RECORD)' : `(+${(delta/1000).toFixed(3)}s)`;
                doc.text(deltaText, margin + 40, yPosition);
                
                // Barre de progression
                const barWidth = 80;
                const barHeight = 4;
                const barX = margin + 90;
                
                // Fond
                doc.setFillColor(224, 224, 224);
                doc.rect(barX, yPosition - 3, barWidth, barHeight, 'F');
                
                // Barre colorée
                const color = delta === 0 ? [76, 175, 80] : 
                              delta < 1000 ? [33, 150, 243] : 
                              delta < 2000 ? [255, 152, 0] : [244, 67, 54];
                doc.setFillColor(...color);
                doc.rect(barX, yPosition - 3, (barWidth * percentage / 100), barHeight, 'F');
                
                yPosition += 7;
            });
        }
        
        // ========== PAGE GPS ==========
        
        if (sessionData.gpsTrack && sessionData.gpsTrack.length > 0) {
            doc.addPage();
            yPosition = 20;
            
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(25, 118, 210);
            doc.text('Informations GPS', margin, yPosition);
            yPosition += 10;
            
            const track = sessionData.gpsTrack;
            const speeds = track.map(p => p.spd || p.speed || 0).filter(s => s > 0);
            
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(0, 0, 0);
            
            const gpsData = [
                ['Points GPS', track.length],
                ['Distance parcourue', `${safeNumber(distance, 2)} km`],
                ['Vitesse minimale', speeds.length > 0 ? `${safeNumber(Math.min(...speeds), 1)} km/h` : '-'],
                ['Vitesse maximale', speeds.length > 0 ? `${safeNumber(Math.max(...speeds), 1)} km/h` : '-'],
                ['Vitesse moyenne', speeds.length > 0 ? `${safeNumber(speeds.reduce((a,b) => a+b, 0) / speeds.length, 1)} km/h` : '-']
            ];
            
            gpsData.forEach(([label, value]) => {
                doc.setFont(undefined, 'bold');
                doc.text(`${label}:`, margin, yPosition);
                doc.setFont(undefined, 'normal');
                doc.text(String(value), margin + 70, yPosition);
                yPosition += 7;
            });
        }
        
        // ========== FOOTER SUR TOUTES LES PAGES ==========
        
        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text(
                `GPS LapTimer - Page ${i}/${pageCount}`,
                pageWidth / 2,
                pageHeight - 10,
                { align: 'center' }
            );
        }
        
        // ========== TÉLÉCHARGER ==========
        
        const filename = `session_${sessionData.id || Date.now()}_rapport.pdf`;
        doc.save(filename);
        
        console.log('✅ PDF généré avec succès:', filename);
        
    } catch (error) {
        alert(`❌ Erreur lors de la génération du PDF:\n${error.message}\n\nVérifiez la console pour plus de détails.`);
        console.error('Erreur complète PDF:', error);
    }
}

// ========== FONCTION AUXILIAIRE: CALCULER LA DISTANCE ==========
function calculateTotalDistance(track) {
    if (!track || track.length < 2) return 0;
    
    let totalDistance = 0;
    for (let i = 1; i < track.length; i++) {
        const p1 = track[i - 1];
        const p2 = track[i];
        
        if (p1.lat && p1.lng && p2.lat && p2.lng) {
            totalDistance += haversineDistance(p1.lat, p1.lng, p2.lat, p2.lng);
        }
    }
    return totalDistance;
}

// ========== FONCTION AUXILIAIRE: DISTANCE HAVERSINE ==========
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Rayon de la Terre en km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}
</script>


</body>
</html>
